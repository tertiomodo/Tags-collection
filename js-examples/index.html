<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript examples</title>
  <!--Swiper css-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@8/swiper-bundle.min.css" />
  <!--Accordion css-->
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css" />
  <!--Select css-->
  <link rel="stylesheet" href="libs/css/choices.min.css" />
  <!--Scrollbar css-->
  <link rel="stylesheet" href="https://unpkg.com/simplebar@latest/dist/simplebar.css" />
  <!--Main css-->
  <link rel="stylesheet" href="styles/main.css" />
  <link rel="icon" href="assets/img/js-icon.ico" />
</head>

<body class="body">
  <div class="content">
    <!-- Block 01 start -->
    <div class="b01 block">
      <p class="title">
        <span class="title-number">01.</span> Математические функции Math.
      </p>
      <p class="text">
        <span class="text-offset">Math.</span> - это готовые математические
        функции (объекты) которые встроены в JS, в этом блоке мы приведем
        самые популярные и часто используемые, но с полным списком этих
        функций вы можете ознакомиться на
        <a class="link" href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math"
          target="_blank">MDN</a>
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Получение абсолютного (положительного) значения числа</span>
<span class="value">Math</span>.<span class="selector">abs</span>(-20); <span class="comment">// 20</span>
<span class="value">Math</span>.<span class="selector">abs</span>(20); <span class="comment">// 20</span>

<span class="comment">// Число PI, sin, cos, tan, atan</span>
<span class="value">Math</span>.<span class="selector">sin</span>(<span class="value">Math</span>.<span class="selector">PI</span> / 2); <span class="comment">// 1, синус 90°</span>
<span class="value">Math</span>.<span class="selector">cos</span>(<span class="value">Math</span>.<span class="selector">PI</span> * 2); <span class="comment">// 1, косинус 360°</span>
<span class="value">Math</span>.<span class="selector">tan</span>(0); <span class="comment">// 0, тангенс 0°</span>
<span class="value">Math</span>.<span class="selector">atan</span>(0); <span class="comment">// 0, арктангенс 0°</span>

<span class="comment">// Натуральный логарифм (ln)</span>
<span class="value">Math</span>.<span class="selector">log</span>(<span class="value">Math</span>.<span class="selector">E</span>); <span class="comment">// 1</span>

<span class="comment">// Округление</span>
<span class="value">Math</span>.<span class="selector">round</span>(3.8); <span class="comment">// 4, математическое округление</span>
<span class="value">Math</span>.<span class="selector">round</span>(3.2); <span class="comment">// 3</span>
<span class="value">Math</span>.<span class="selector">round</span>(3.5); <span class="comment">// 4</span>
<span class="value">Math</span>.<span class="selector">floor</span>(3.9); <span class="comment">// 3, округление вниз</span>
<span class="value">Math</span>.<span class="selector">ceil</span>(3.2); <span class="comment">// 4, округление вверх</span>

<span class="comment">// Метод округляющий число до n знаков после запятой. Данный метод возвращает строку, поэтому нужно использовать унарный +</span>
<span class="comment">// Данный метод рекомендуется использовать при сложении чисел с плавающей точкой, во избежание неточных вычислений</span>
<span class="property">const</span> <span class="value">number</span> = 1.23456789;
+<span class="value">number</span>.<span class="selector">toFixed</span>(n);

<span class="comment">// Наибольшее и наименьшее число</span>
<span class="value">Math</span>.<span class="selector">max</span>(10, 1, -40, 12, 5); <span class="comment">// 12, наибольшее из переданных чисел</span>
<span class="value">Math</span>.<span class="selector">min</span>(10, 1, -40, 12, 5); <span class="comment">// -40, наименьшее из переданных чисел</span>

<span class="comment">// Возведение в степень</span>
<span class="value">Math</span>.<span class="selector">pow</span>(10, 3); <span class="comment">// 1000, 10^3, аналогичная запись 10 ** 3</span>
<span class="value">Math</span>.<span class="selector">sqrt</span>(16); <span class="comment">// 4, квадратный корень числа</span>
<span class="value">Math</span>.<span class="selector">pow</span>(16, 0.5); <span class="comment">// 4, тоже квадратный корень</span>

<span class="comment">// Случайные числа</span>
<span class="value">Math</span>.<span class="selector">random</span>(); <span class="comment">// Случайное число от 0 до 1</span>
<span class="value">Math</span>.<span class="selector">round</span>(<span class="value">Math</span>.<span class="selector">random</span>() * 100); <span class="comment">// Случайное число от 0 до 100</span>
<span class="value">Math</span>.<span class="selector">round</span>(<span class="value">Math</span>.<span class="selector">random</span>() * 70) + 50; <span class="comment">// Случайное число от 50 до 120</span>
</code>
</pre>
      </div>
    </div>
    <!-- Block 01 end -->
    <!-- Block 02 start -->
    <!-- <div class="b02 block">
      <p class="title">
        <span class="title-number">02.</span> Строки и функции для работы с ними.
      </p>
      <p class="text">
        <span class="text-offset">Строки</span> - это ...
      </p>
    </div> -->
    <!-- Block 02 end -->
    <!-- Block 03 start -->
    <div class="b03 block">
      <p class="title"><span class="title-number">03.</span> Функции.</p>
      <p class="text">
        <span class="text-offset">Функции</span> - это основные строительные
        блоки программы, предназначенные для того чтобы выполнять одинаковый
        код в различных местах, путём вызова созданной функции.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Варианты синтаксиса функций:</span>
<span class="comment">// Function declaration - Объявление функции. Стандартный вид записи функции.</span>
<span class="cycle-function">function</span> <span class="selector">sayHello</span>(<span class="value">arguments</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Hello"</span>);
}

<span class="selector">sayHello</span>(); <span class="comment">// Hello</span>
<span class="selector">sayHello</span>(); <span class="comment">// Hello</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Function expression - Функциональное выражение. Позволяет создавать функцию сразу присваивая результат ее работы переменной.</span>
<span class="property">const</span> <span class="value">sayHello</span> = <span class="cycle-function">function</span>(<span class="value">arguments</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Hello"</span>);
}

<span class="selector">sayHello</span>(); <span class="comment">// Hello</span>
<span class="selector">sayHello</span>(); <span class="comment">// Hello</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Arrow function - Стрелочная функция. Основным приемуществом является укороченный синтаксис записи.</span>
<span class="property">const</span> <span class="value">sayHello</span> = (<span class="value">arguments</span>) <span class="cycle-function">=&gt;</span> {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Hello"</span>);
}

<span class="selector">sayHello</span>(); <span class="comment">// Hello</span>
<span class="selector">sayHello</span>(); <span class="comment">// Hello</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Стрелочные функции позволяют писать простые вычисления в одну строчку</span>
<span class="property">const</span> <span class="value">sum</span> = (<span class="value">a</span>, <span class="value">b</span>) <span class="cycle-function">=&gt;</span> <span class="value">a</span> + <span class="value">b</span>;

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">sum</span>(1, 2)); <span class="comment">// 3</span>

<span class="comment">// Эта стрелочная функция представляет собой более короткую форму:</span>
<span class="comment">   const sum = function(a, b) {
    return a + b;
   };</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Если у нас один аргумент, то круглые скобки можно не писать</span>
<span class="property">const</span> <span class="value">double</span> = <span class="value">a</span> <span class="cycle-function">=&gt;</span> <span class="value">a</span> * 2;

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">double</span>(3)); <span class="comment">// 6</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// В каких ситуациях использовать Function Declaration/Expression?</span>
<span class="comment">// 1. Когда нам нужен метод объекта this (у стрелочных функций нет доступа к this).</span>
<span class="property">const</span> <span class="value">obj</span> {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="selector">printName</span>() {
    <span class="value">console</span>.<span class="selector">log</span>(<span class="property">this</span>.<span class="value">name</span>);
  }
}

<span class="comment">// 2. В обработчиках событий, когда нам нужен метод объекта this.</span>
<span class="value">input</span>.<span class="selector">addEventListener</span>(<span class="string">"input"</span>, <span class="cycle-function">function</span>() {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="property">this</span>.<span class="value">value</span>);
});

<span class="comment">// 3. Простые именованные функции, используемые в коде, лучше так же объявлять как function с именем.</span>
<span class="cycle-function">function</span> <span class="selector">sayHello</span>() {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Hello"</span>);
}

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// В каких ситуациях использовать Arrow Function?</span>
<span class="comment">// 1. В обработчиках событий если нам не нужен доступ к this.</span>
<span class="value">button</span>.<span class="selector">addEventListener</span>(<span class="string">"click"</span>, () <span class="cycle-function">=&gt;</span> {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"User clicked!"</span>);
});

<span class="comment">// 2. Когда мы передаем функцию в качестве параметра в другую функцию.</span>
<span class="selector">setInterval</span>(() <span class="cycle-function">=&gt;</span> {<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"tick"</span>);}, 1000);

<span class="comment">// 3. IIFE - Немедленный вызов функции после ее объявления.</span>
(() <span class="cycle-function">=&gt;</span> {})() <span class="comment">// vs (function() {})()</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Рекурсия</span>
<span class="comment">// Рекурсией называется вызов функцией самой себя</span>
<span class="comment">// Рекурсию используют когда вычисление функции можно свести к её более простому вызову, пока значение не станет очевидно.</span>
<span class="comment">// Реализуем рекурсию на примере функции возведения в степень pow(x, n), где x - число, n - степень</span>

<span class="cycle-function">function</span> <span class="selector">pow</span>(<span class="value">x</span>, <span class="value">n</span>) {
  <span class="cycle-function">if</span> (<span class="value">n</span> === 1) {
    <span class="cycle-function">return</span> <span class="value">x</span>;
  } <span class="cycle-function">else</span> {
    <span class="cycle-function">return</span> <span class="value">x</span> * <span class="selector">pow</span>(<span class="value">x</span>, <span class="value">n</span> - 1);
  }
}
<span class="value">console</span>.<span class="selector">log</span>(<span class="selector">pow</span>(2, 4)); <span class="comment">// 16</span>

<span class="comment">// Когда вызывается рекурсивная функция, исполнение делится на две ветви:</span>
<span class="comment">// 1. if (n === 1) return x - База рекурсии, тк эта ветвь сразу приводит к очевидному результату pow(x, 1) = x</span>
<span class="comment">// 2. x * (x, n - 1) - Шаг рекурсии, мы сводим задачу к более простому действию. Последующие шаги упрощают задачу пока n не достигнет 1. Другими словами, функция pow рекурсивно вызывает саму себя до n === 1.</span>

<span class="comment">// Полный цикл функции pow(2, 4) выглядит следующим образом:</span>
<span class="comment">// 1. pow(2, 4) = 2 * pow(2, 3)</span>
<span class="comment">// 2. pow(2, 3) = 2 * pow(2, 2)</span>
<span class="comment">// 3. pow(2, 2) = 2 * pow(2, 1)</span>
<span class="comment">// 3. pow(2, 1) = 2</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Функцию выше можно написать короче, используя оператор ?</span>
<span class="cycle-function">function</span> <span class="selector">pow</span>(<span class="value">x</span>, <span class="value">n</span>) {
  <span class="cycle-function">return</span> (<span class="value">n</span> === 1) ? <span class="value">x</span> : <span class="value">x</span> * <span class="selector">pow</span>(<span class="value">x</span>, <span class="value">n</span> - 1);
}

<span class="comment">// Общее количество вызовов называют глубиной рекурсии, в нашем случае она равна n</span>
<span class="comment">// Любая рекурсия может быть переделана в цикл, и как правило цикл будет работать эффективнее, но может быть сложнее для понимания и анализа, нежели рекурсивная функция.</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Рассмотрим следующий пример, в нем представлен объект company в котором есть массивы представляющие отделы компании, с сотрудниками в виде объектов в них.</span>
<span class="comment">// Также в компании есть подотделы, которые представлены в виде вложенных объектов, в которых так же есть массивы с объектами в виде сотрудников.</span>
<span class="comment">// Задача: необходимо подсчитать зарплату всех сотрудников и вывести общую сумму. Реализуем это при помощи рекурсии.</span>

<span class="property">const</span> <span class="value">company</span> = {
  <span class="value">sales:</span> [{<span class="value">name:</span> <span class="string">'John'</span>, <span class="value">salary:</span> 1000}, {<span class="value">name:</span> <span class="string">'Alice'</span>, <span class="value">salary:</span> 600}],
  <span class="value">development:</span> {
    <span class="value">sites:</span> [{<span class="value">name:</span> <span class="string">'Peter'</span>, <span class="value">salary:</span> 2000}, {<span class="value">name:</span> <span class="string">'Alex'</span>, <span class="value">salary:</span> 1800}],
    <span class="value">internals:</span> [{<span class="value">name:</span> <span class="string">'Jack'</span>, <span class="value">salary:</span> 1300}],
  },
};

<span class="cycle-function">function</span> <span class="selector">sumSalaries</span>(<span class="value">department</span>) {
  <span class="comment">// База рекурсии. Берем массив, из объектов внутри достаём зарплаты и складываем их</span>
  <span class="cycle-function">if</span> (<span class="object">Array</span>.<span class="selector">isArray</span>(<span class="value">department</span>)) {
    <span class="cycle-function">return</span> <span class="value">department</span>.<span class="selector">reduce</span>((<span class="value">sum</span>, <span class="value">current</span>) <span class="cycle-function">=&gt;</span> <span class="value">sum</span> + <span class="value">current</span>.<span class="value">salary</span>);
  } <span class="cycle-function">else</span> {
    <span class="property">let</span> <span class="value">sum</span> = 0;
    
  <span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">prop</span> <span class="property">of</span> <span class="object">Object</span>.<span class="selector">values</span>(<span class="value">department</span>)) {
    <span class="comment">// Шаг рекурсии. Для каждого массива вызывается таже самая функция в рекурсии, чтобы в конечном итоге попасть в базу рекурсии и сложить всю сумму</span>
    <span class="value">sum</span> += <span class="selector">sumSalaries</span>(<span class="value">prop</span>);
  }

  <span class="cycle-function">return</span> <span class="value">sum</span>;
  }
}

<span class="value">console</span>.<span class="selector">log</span>(<span class="selector">sumSalaries</span>(<span class="value">company</span>)); <span class="comment">// 6700</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Остаточные параметры. Оператор три точки ...</span>
<span class="comment">// Оператор ... можно использовать, когда мы не знаем сколько аргументов будет в функции, в этом случае ... становится оператором остаточных параметров.</span>
<span class="comment">// Оператор остаточных параметров можно читать как "собери оставшиеся параметры и положи их в массив"</span>
<span class="comment">// Оператор остаточных параметров (когда он вызывается в аргументах функции), необходимо указывать в самом конце, при наличии, других аргументов, иначе это вызовет ошибку</span>
<span class="cycle-function">function</span> <span class="selector">sumAll</span>(...<span class="value">arguments</span>) {
  <span class="property">let</span> <span class="value">sum</span> = 0;

  <span class="cycle-function">for</span> (<span class="property">let</span> <span class="value">argument</span> <span class="property">of</span> <span class="value">arguments</span>) <span class="value">sum</span> += <span class="value">argument</span>;
  <span class="cycle-function">return</span> <span class="value">sum</span>;
}

<span class="value">console</span>.<span class="selector">log</span>(<span class="selector">sumAll</span>(1)); <span class="comment">// 1</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="selector">sumAll</span>(1, 2)); <span class="comment">// 3</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="selector">sumAll</span>(1, 2, 3)); <span class="comment">// 6</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Замыкания</span> - это дочерняя функция,
        которая находится внутри родительской функции и которая запоминает
        свои внешние переменные и может получить к ним доступ, даже когда
        родительская функция прекратила свою работу.
      </p>
      <p class="text">
        Замыкание представляет из себя функцию которая находится в другой
        (вызываемой) функции, при вызове родительской функии, нам возвращается
        функция которая находится внутри (дочерняя). Суть работы программы
        заключается в замыкании лексического окружения возвращаемой функции на
        переменные объявленные в родительской функции.
      </p>
      <p class="text">
        Ниже, в примерах кода, будут представлены различные способы
        использования замыкания и синтаксис.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// В этом примере, вызов функции createCalcFunction(1) вернет нам дочернюю функцию, чтобы ей воспользоваться, мы должны присвоить ее переменной и вызвать.</span>
<span class="cycle-function">function</span> <span class="selector">createCalcFunction</span>(<span class="value">n</span>) {
  <span class="cycle-function">return</span> <span class="cycle-function">function</span>() {
    <span class="value">console</span>.<span class="selector">log</span>(<span class="value">n</span> + 1);
  }
}

<span class="comment">// Не даст результатов, потому что нам вернулась дочерняя функция которая не вызвалась</span>
<span class="comment">// Работа функции createCalcFunction закончилась когда встретила return - те на том чтобы вернуть функцию не вызывая ее при этом</span>
<span class="selector">createCalcFunction</span>(1);

<span class="comment">// Присвоим ее переменной calc и вызовем в качестве функции.</span>
<span class="property">const</span> <span class="value">calc</span> = <span class="selector">createCalcFunction</span>(1);
<span class="selector">calc</span>();
<span class="comment">// 2 - Сработало, вызвалась дочерняя присвоенная в переменную функция, при этом она замкнулась на родительскую переменную n</span>

------------------------------------------------------------------------------------------------------------
<span class="cycle-function">function</span> <span class="selector">createIncrementor</span>(<span class="value">n</span>) {
  <span class="cycle-function">return</span> <span class="cycle-function">function</span>(<span class="value">num</span>) {
    <span class="cycle-function">return</span> <span class="value">n</span> + <span class="value">num</span>;
  }
}

<span class="property">const</span> <span class="value">plusOne</span> = <span class="selector">createIncrementor</span>(1); <span class="comment">// Замкнули функцию createIncrementor на единице (n).</span>
<span class="property">const</span> <span class="value">plusTen</span> = <span class="selector">createIncrementor</span>(10); <span class="comment">// Замкнули функцию createIncrementor на десяти (n).</span>

<span class="comment">// Передаем число в параметр num, функции plusOne(num), помним что plusOne мы замкнули на 1</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">plusOne</span>(1)); <span class="comment">// 2</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">plusOne</span>(50)); <span class="comment">// 51</span>

<span class="comment">// Передаем число в параметр num, функции plusTen(num), помним что plusTen мы замкнули на 10</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">plusTen</span>(1)); <span class="comment">// 11</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">plusTen</span>(50)); <span class="comment">// 60</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Создадим функцию генерирующую URL адрес.</span>
<span class="cycle-function">function</span> <span class="selector">urlGenerator</span>(<span class="value">domain</span>) {
  <span class="cycle-function">return</span> <span class="cycle-function">function</span>(<span class="value">url</span>) {
    <span class="cycle-function">return</span> <span class="string">`https://</span><span class="property">{$</span><span class="value">url</span><span class="property">}</span><span class="string">.</span><span class="property">{$</span><span class="value">domain</span><span class="property">}</span><span class="string">`</span>;
  }
}

<span class="property">const</span> <span class="value">comUrl</span> = <span class="selector">urlGenerator</span>(<span class="string">"com"</span>); <span class="comment">// Замкнули domain на "com" - urlGenerator("com")</span>
<span class="property">const</span> <span class="value">ruUrl</span> = <span class="selector">urlGenerator</span>(<span class="string">"ru"</span>); <span class="comment">// Замкнули domain на "ru" - urlGenerator("ru")</span>

<span class="comment">// Передаем строки в параметр url</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">comUrl</span>(<span class="string">"google"</span>)); <span class="comment">// https://google.com</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">ruUrl</span>(<span class="string">"yandex"</span>)); <span class="comment">// https://yandex.com</span>
</code>
</pre>
      </div>
    </div>
    <!-- Block 03 end -->
    <!-- Block 04 start -->
    <div class="b04 block">
      <p class="title">
        <span class="title-number">04.</span> Массивы (arrays).
      </p>
      <p class="text">
        <span class="text-offset">Массивы</span> - это сложный тип данных
        который позволяет хранить множество элементов в определеном порядке.
        Элементы массива заключаются в квадратные скобки и перечисляются через
        запятую
        <span class="text-bg">[<span class="string">"element"</span>,
          <span class="string">"element"</span>, ...];</span>
      </p>
      <p class="text">
        В массиве каждый элемент имеет свой порядковый номер, в JS порядковые
        номера принято называть индексами, индекс первого элемента всегда
        будет 0
      </p>
      <p class="text">
        Этот тип данных часто применяется на практике, например, у нас есть
        интернет магазин и список товаров в нем, товары представляют из себя
        список элементов которые появляются в определенном порядке, например
        по возрастанию цены, для подобных ситуаций нам понадобится массив, в
        котором есть строго упорядоченный список элементов.
      </p>
      <p class="text">
        Ниже, в примерах кода, будут представлены различные виды синтаксиса
        объявления массива.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<a class="link" href="https://learn.javascript.ru/array-methods" target="_blank">Подробнее о методе массивов</a>
<span class="comment">// Литеральная запись массива - явная запись в массив того, что мы хотим в нем видеть при его объявлении.</span>
<span class="property">const</span> <span class="value">fruits</span> = [<span class="string">"Яблоко"</span>, <span class="string">"Апельсин"</span>, <span class="string">"Груша"</span>, <span class="string">"Банан"</span>, <span class="string">"Манго"</span>];

<span class="comment">// Далее мы можем обращаться к нашему массиву при помощи индексов.</span>
<span class="value">fruits</span>[0]; <span class="comment">// "Яблоко"</span>
<span class="value">fruits</span>[4]; <span class="comment">// "Манго"</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Пустой массив - если мы не знаем какие данные будут в массиве, мы создаем пустой массив и далее заполняем его данными.</span>
<span class="property">const</span> <span class="value">alphabet</span> = [];

<span class="comment">// Метод push добавляет элемент в конец массива:</span>
<span class="value">alphabet</span>.<span class="selector">push</span>(<span class="string">"Г"</span>);
<span class="value">alphabet</span>.<span class="selector">push</span>(<span class="string">"Д"</span>);
<span class="value">alphabet</span>.<span class="selector">push</span>(<span class="string">"Е"</span>, <span class="string">"Ж"</span>, <span class="string">"З"</span>);

<span class="comment">// Метод pop удаляет элемент из конца массива и возвращает его, работает по принципу arr.at(-1), но при этом еще и удаляет элемент:</span>
<span class="value">alphabet</span>.<span class="selector">pop</span>(); <span class="comment">// Удалил и вывел букву "З"</span>

<span class="comment">// Метод unshift добавляет элемент в начало массива:</span>
<span class="value">alphabet</span>.<span class="selector">unshift</span>(<span class="string">"В"</span>);
<span class="value">alphabet</span>.<span class="selector">unshift</span>(<span class="string">"А"</span>, <span class="string">"Б"</span>);

<span class="comment">// Метод shift удаляет элемент из начала массива и выводит его:</span>
<span class="value">alphabet</span>.<span class="selector">unshift</span>(); <span class="comment">// Удалил и вывел букву "А"</span>

<span class="comment">// Итого наш заполненный массив имеет вид:</span>
<span class="property">const</span> <span class="value">alphabet</span> = [<span class="string">"Б"</span>, <span class="string">"В"</span>, <span class="string">"Г"</span>, <span class="string">"Д"</span>, <span class="string">"Ж"</span>];

<span class="comment">// После того как мы заполнили массив элементами, мы можем проделать с ним оперции ниже, например, мы можем получить длину массива.</span>
<span class="value">alphabet</span>.<span class="value">length</span>; <span class="comment">// 5, тк у нас в массиве 5 элементов (букв)</span>

<span class="comment">// Попробуем получить последний элемент массива зная его длину.</span>
<span class="value">alphabet</span>[<span class="value">alphabet</span>.<span class="value">length</span> - 1]; <span class="comment">// Получили букву "Ж", мы вычли 1 из-за того что начинаем считать с нуля</span>

<span class="comment">// Еще один способо получения последнего элемента массива с использованием arr.at</span>
<span class="value">alphabet</span>.<span class="selector">at</span>(-1); <span class="comment">// Так же получаем букву "Ж"</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// При помощи индекса мы можем не только обращаться к элементу массива но и заменять его на новый.</span>
<span class="property">const</span> <span class="value">greetings</span> = [<span class="string">"Hello"</span>, <span class="string">"Good morning"</span>, <span class="string">"Good evnng"</span>, <span class="string">"Good afternoon</span>];
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">greetings</span>[2]); <span class="comment">// "Good evnng" - опечатка</span>

<span class="comment">// Исправим опечатку:</span>
<span class="value">greetings</span>[2] = <span class="string">"Good evening"</span>;
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">greetings</span>[2]); <span class="comment">// "Good evening" - исправлено!</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// В массиве могут храниться элементы любого типа</span>
<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"Яблоко"</span>, {name: <span class="string">"Джон"</span>}, <span class="property">true</span>, <span class="cycle-function">function</span> () {<span class="value">alert</span><span class="string">"Привет!"</span>;}];

<span class="comment">// Получить элемент с индексом 1 (объект) и затем показать его свойство</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>[1].name); <span class="comment">// "Джон"</span>

<span class="comment">// Получить элемент с индексом 3 (функция) и выполнить её</span>
<span class="value">arr</span>[3]() <span class="comment">// "Привет!"</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Массивы могут содержать в себе элементы являющиеся массивами. Это можно использовать для хранения матриц.</span>
<span class="property">const</span> <span class="value">matrix</span> = [[1, 2, 3], [4, 5, 6]. [7, 8, 9]];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">matrix</span>[1][1]);
<span class="comment">// 5, центральный элемент</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Метод массива splice</span>
<span class="comment">// Изменяет arr начиная с индекса start, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место</span>

<span class="value">arr</span>.<span class="selector">splice</span>(start, deleteCount, elem1, ..., elemN);

------------------------------------------------------------------------------------------------------------
<span class="comment">// Примеры использования:</span>
<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"Я"</span>, <span class="string">"Изучаю"</span>, <span class="string">"JavaScript"</span>, <span class="string">"прямо"</span>, <span class="string">"сейчас"</span>];

<span class="comment">// Здесь мы указываем что хотим начиная с 0 индекса, удалить 3 элемента и заменить их на две строки</span>
<span class="value">arr</span>.<span class="selector">splice</span>(0, 3, <span class="string">"Давай"</span>, <span class="string">"танцевать"</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>); <span class="comment">// Давай танцевать прямо сейчас</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Метод splice может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:</span>

<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"Я"</span>, <span class="string">"Изучаю"</span>, <span class="string">"JavaScript"</span>];

<span class="comment">// С индекса 2, удалить 0 элементов и вставить две строки</span>
<span class="value">arr</span>.<span class="selector">splice</span>(2, 0, <span class="string">"сложный"</span>, <span class="string">"язык"</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>); <span class="comment">// Я изучаю сложный язык JavaScript</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Можно использовать отрицательные индексы</span>

<span class="property">const</span> <span class="value">arr</span> = [1, 2, 5];

<span class="comment">// С индекса -1 (перед последним элементом), удалить 0 элементов и вставить две цифры</span>
<span class="value">arr</span>.<span class="selector">splice</span>(-1, 0, 3, 4);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>); <span class="comment">// 1, 2, 3, 4, 5</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Метод arr.slice [start, end] - возвращает новый массив в который копирует все элементы с индекса start до end не включая end</span>
<span class="comment">// start и end могут быть отрицательные, в этом случае отсчет будет вестись с конца массива</span>

<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"t"</span>, <span class="string">"e"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">slice</span>(1, 3)); <span class="comment">// e, s (копирует элементы с 1 до 3)</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">slice</span>(-2)); <span class="comment">// s, t (копирует элементы с -2 до конца)</span>

<span class="comment">// Можно вызывать arr.slice() без аргументов, что позволит создать копию массива arr для дальнейших преобразований не влияя на оригинальный массив.</span>
<span class="property">const</span> <span class="value">arrCopy</span> = <span class="value">arr</span>.<span class="selector">slice</span>();

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Метод arr.concat(args1, ..., argsN); - Создает новый массив, в котоырй копирует данные из других массивов и дополнительные значения.</span>
<span class="comment">// Он принимает любое количество аргументов, которые могут быть массивами или простыми значениями</span>

<span class="property">const</span> <span class="value">arr</span> = [1, 2];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">concat</span>(3, 4)); <span class="comment">// Создается новый массив: 1, 2, 3, 4</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">concat</span>([3, 4], [5], 6)); <span class="comment">// Создается новый массив: 1, 2, 3, 4, 5, 6</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Поиск в массиве при помощи: </span>
<span class="comment">// indexOf(item, from) - Возвращает индекс найденного элемента, если его нет вернет -1, item - искомый элемент массива, from - индекс начала поиска</span>
<span class="comment">// includes(item, from) - Возвращает true или false в зависимости есть ли элемент в массиве, item - искомый элемент массива, from - индекс начала поиска</span>
<span class="comment">// По умолчанию поиск ведется с начала, поэтому можно указывать только необходимый аргумент</span>

<span class="property">const</span> <span class="value">arr</span> = [1, 0, false];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">indexOf</span>(1)); <span class="comment">// 0 - вернул индекс цифры 1 в массиве</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">indexOf</span>(0)); <span class="comment">// 1 - вернул индекс цифры 0 в массиве</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">indexOf</span>(null)); <span class="comment">// -1 - элемента "null" нет в массиве</span>

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>.<span class="selector">includes</span>(false)); <span class="comment">// true - элемент "false" присутствует в массиве</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// find и findIndex/findLastIndex - Поиск в массиве с объектами по поределенным условиям</span>
<span class="comment">// Синтаксис:</span>

<span class="property">const</span> <span class="value">result</span> = <span class="value">arr</span>.<span class="selector">find</span>(<span class="cycle-function">function</span>(item, index, array) {
  <span class="comment">// Если true, возвращается текущий item и перебор прекращается</span>
  <span class="comment">// Если все итерации оказались ложными возвращается undefined</span>
  <span class="comment">// item - очередной элемент</span>
  <span class="comment">// index - его индекс</span>
  <span class="comment">// array - сам массив</span>
});

------------------------------------------------------------------------------------------------------------
<span class="comment">// Например, у нас есть массив пользователей, каждый из которых имеет поля id и name. Найдем пользователя с id === 1:</span>

<span class="property">const</span> <span class="value">users</span> = [
  {<span class="value">id:</span> 1, <span class="value">name:</span> <span class="string">"Вася"</span>},
  {<span class="value">id:</span> 2, <span class="value">name:</span> <span class="string">"Петя"</span>},
  {<span class="value">id:</span> 3, <span class="value">name:</span> <span class="string">"Маша"</span>},
];

<span class="comment">// На практике аргументы кроме item используются редко</span>
<span class="property">const</span> <span class="value">user</span> = <span class="value">users</span>.<span class="selector">find</span>(<span class="value">item</span> <span class="cycle-function">=&gt;</span> <span class="value">item</span>.<span class="value">id</span> === 1);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>.<span class="value">name</span>); <span class="comment">// Вася</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// arr.findIndex - возвращает индекс на котором был найден элемент, если элемента нет, возвращается -1</span>
<span class="comment">// arr.findLstIndex - похож на findIndex но ищет справа наево, подходит для поиска последних пользователей</span>

<span class="property">const</span> <span class="value">users</span> = [
  {<span class="value">id:</span> 1, <span class="value">name:</span> <span class="string">"Вася"</span>},
  {<span class="value">id:</span> 2, <span class="value">name:</span> <span class="string">"Петя"</span>},
  {<span class="value">id:</span> 3, <span class="value">name:</span> <span class="string">"Маша"</span>},
  {<span class="value">id:</span> 4, <span class="value">name:</span> <span class="string">"Вася"</span>},
];

<span class="comment">// Найти индекс первого Васи:</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">users</span>.<span class="selector">findIndex</span>(<span class="value">item</span> <span class="cycle-function">=&gt;</span> <span class="value">item</span>.<span class="value">name</span> === <span class="string">"Вася"</span>)); <span class="comment">// 0</span>

<span class="comment">// Найти индекс последнего Васи:</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">users</span>.<span class="selector">findLastIndex</span>(<span class="value">item</span> <span class="cycle-function">=&gt;</span> <span class="value">item</span>.<span class="value">name</span> === <span class="string">"Вася"</span>)); <span class="comment">// 3</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// arr.filter(function) - похож на arr.find, но он возвращает не 1 элемент, а массив из всех подходящих элементов.</span>
<span class="comment">// Синтаксис:</span>

<span class="property">const</span> <span class="value">results</span> = <span class="value">arr</span>.<span class="selector">filter</span>(<span class="cycle-function">function</span>(item, index, array) {
  <span class="comment">// Если true - элемент добавляется к results и перебор продолжается</span>
  <span class="comment">// Если ничего не найдено, возвращается пустой массив</span>
  <span class="comment">// item - очередной элемент</span>
  <span class="comment">// index - его индекс</span>
  <span class="comment">// array - сам массив</span>
});

------------------------------------------------------------------------------------------------------------
<span class="comment">// Пример использования:</span>

<span class="property">const</span> <span class="value">users</span> = [
  {<span class="value">id:</span> 1, <span class="value">name:</span> <span class="string">"Вася"</span>},
  {<span class="value">id:</span> 2, <span class="value">name:</span> <span class="string">"Петя"</span>},
  {<span class="value">id:</span> 3, <span class="value">name:</span> <span class="string">"Маша"</span>},
];

<span class="comment">// Возвращает массив состоящий из 2х первых пользователей</span>
<span class="property">const</span> <span class="value">someUsers</span> = <span class="value">users</span>.<span class="selector">filter</span>(<span class="value">item</span> <span class="cycle-function">=&gt;</span> <span class="value">item</span>.<span class="value">id</span> &lt; 3);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">someUsers</span>); <span class="comment">// [ { id: 1, name: "Вася" }, { id: 2, name: "Петя" } ]</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// arr.map(function) - Вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции</span>
<span class="comment">// Синтаксис:</span>

<span class="property">const</span> <span class="value">result</span> = <span class="value">arr</span>.<span class="selector">map</span>(<span class="cycle-function">function</span>(item, index, array) {
  <span class="comment">// Возвращается новое значение вместо элемента</span>
  <span class="comment">// item - очередной элемент</span>
  <span class="comment">// index - его индекс</span>
  <span class="comment">// array - сам массив</span>
});

------------------------------------------------------------------------------------------------------------
<span class="comment">// Например здесь мы преобразуем каждый элемент в его длину:</span>

<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"Hello"</span>, <span class="string">"my"</span>, <span class="string">"dear"</span>, <span class="string">"friend"</span>];

<span class="property">const</span> <span class="value">lengths</span> = <span class="value">arr</span>.<span class="selector">map</span>(<span class="value">item</span> <span class="cycle-function">=&gt;</span> <span class="value">item</span>.<span class="property">length</span>));

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">lengths</span>); <span class="comment">// [ 5, 2, 4, 7 ]</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// arr.sort(fn) - Сортирует массив на месте, меняя в нем порядок элементов.</span>
<span class="comment">// По умолчанию элементы в массиве сортируются как строки, для того чтобы изменить способ сортировки, нужно передать в sort функцию (fn)</span>
<span class="comment">// Для функции сравнения чисел требуется вернуть любое положительное число чтобы сказать "больше" или любое отрицательное чтобы сказать "меньше"</span>
<span class="comment">// Поэтому мы можем использовать такой универсальный код для сравнения чисел:</span>

<span class="property">const</span> <span class="value">arr</span> = [1, 15, 2, 4];

<span class="value">arr</span>.<span class="selector">sort</span>((<span class="value">a</span>, <span class="value">b</span>) <span class="cycle-function">=&gt;</span> <span class="value">a</span> - <span class="value">b</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>); <span class="comment">// [ 1, 2, 4, 15 ]</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Для правильной сортировки стран в названиях которых есть подобные буквы Ö, нужно использовать метод localCompare:</span>

<span class="property">const</span> <span class="value">countries</span> = [<span class="string">"Österreich"</span>, <span class="string">"Andorra"</span>, <span class="string">"Vietnam"</span>];

<span class="value">countries</span>.<span class="selector">sort</span>((<span class="value">a</span>, <span class="value">b</span>) <span class="cycle-function">=&gt;</span> <span class="value">a</span>.<span class="selector">localeCompare</span>(<span class="value">b</span>));

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">countries</span>); <span class="comment">// [ "Andorra", "Österreich", "Vietnam" ]</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// arr.reverse() - Меняет порядок элементов в arr на обратный:</span>

<span class="property">const</span> <span class="value">arr</span> = [1, 2, 3, 4, 5];

<span class="value">arr</span>.<span class="selector">reverse</span>();

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>); <span class="comment">// [ 5, 4, 3, 2, 1 ]</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// str.split(delim) - Разбивает строку на массив по указанному разделителю delim</span>

<span class="property">const</span> <span class="value">names</span> = <span class="string">"Вася, Петя, Маша"</span>;

<span class="property">const</span> <span class="value">arr</span> = <span class="value">names</span>.<span class="selector">split</span>(<span class="string">", "</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>); <span class="comment">// [ "Вася", "Петя", "Маша" ]</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// str.split("") - Если в качестве аргумента использовать пустую строку, тогда метод разобьет строку на символы</span>

<span class="property">const</span> <span class="value">str</span> = <span class="string">"test"</span>;

<span class="property">const</span> <span class="value">arr</span> = <span class="value">str</span>.<span class="selector">split</span>(<span class="string">""</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">arr</span>); <span class="comment">// [ "t", "e", "s", "t" ]</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// arr.join(glue) - Создает строку из элементов arr вставляя между элементами glue</span>
<span class="comment">// *Конструкцию из данных методов arr.split("").reverse().join("") можно использовать для переворачивания строки</span>

<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"Вася"</span>, <span class="string">"Петя"</span>, <span class="string">"Маша"</span>];

<span class="property">const</span> <span class="value">stringWithGlue</span> = <span class="value">arr</span>.<span class="selector">join</span>(<span class="string">"; "</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">stringWithGlue</span>); <span class="comment">// "Вася; Петя; Маша"</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// glue не обязательно использовать, можно оставить пустую строку, в таком случае join просто склеит элементы массива между собой</span>

<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"t"</span>, <span class="string">"e"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>];

<span class="property">const</span> <span class="value">stringWithoutGlue</span> = <span class="value">arr</span>.<span class="selector">join</span>(<span class="string">""</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">stringWithoutGlue</span>); <span class="comment">// "test"</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">arr.reduce() / arr.reduceRight()</span>
<span class="comment">// <span class="console-chapter">arr.reduce()</span> - При вызове функции, результат ее предыдущего вызова передается на следующий вызов в качестве первого аргумента (accumulator)</span>
<span class="comment">// Синтаксис:</span>

<span class="property">const</span> <span class="value">value</span> = <span class="value">arr</span>.<span class="selector">reduce</span>(<span class="cycle-function">function</span>(accumulator, item, index, array) {
  <span class="comment">// accumulator - результат предыдущего вызова этой функции, равен initial при первом вызове </span>
  <span class="comment">// item - очередной элемент</span>
  <span class="comment">// index - его индекс</span>
  <span class="comment">// array - сам массив</span>
}, [<span class="value">initial</span>]);

------------------------------------------------------------------------------------------------------------
<span class="comment">// В функцию reduce передано 2 аргумента, этого обычно достаточно</span>
<span class="comment">// Пример с получением всех элементов массива, разберем подробнее что тут происходит:</span>
<span class="comment">// 1. При первом запуске sum равен initial (0), current - первый элемент массива (1). Результат функции равен 1</span>
<span class="comment">// 2. При втором запуске sum = 1, к нему мы добавляем второй элемент массива (2) и возвращаем сумму (3).</span>
<span class="comment">// 3. При третьем запуске sum = 3, к которому мы добавляем следующий элемент и так до конца массива.</span>

<span class="property">const</span> <span class="value">arr</span> = [1, 2, 3, 4, 5];

<span class="property">const</span> <span class="value">value</span> = <span class="value">arr</span>.<span class="selector">reduce</span>((<span class="value">sum</span>, <span class="value">current</span>) <span class="cycle-function">=&gt;</span> <span class="value">sum</span> + <span class="value">current</span>, 0);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">value</span>); <span class="comment">// 15</span>

<span class="comment">// <span class="console-chapter">arr.reduceRight()</span> - Работает аналогично но проходит по массиву справа налево</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// <span class="console-chapter">thisArg</span> - Это this для передаваемой function</span>
<span class="comment">// Почти все методы массива, которые вызывают функции find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg</span>
<span class="comment">// Полный синтаксис этих методов:</span>

<span class="value">arr</span>.<span class="selector">find</span>(<span class="value">func</span>, <span class="value">thisArg</span>);
<span class="value">arr</span>.<span class="selector">filter</span>(<span class="value">func</span>, <span class="value">thisArg</span>);
<span class="value">arr</span>.<span class="selector">map</span>(<span class="value">func</span>, <span class="value">thisArg</span>);

------------------------------------------------------------------------------------------------------------
<span class="comment">// Например, тут мы используем метод объекта army как фильтр, и thisArg передаёт ему контекст:</span>

<span class="property">const</span> <span class="value">army</span> = {
  <span class="value">minAge</span>: 18,
  <span class="value">maxAge</span>: 27,
  <span class="selector">canJoin</span>(<span class="value">user</span>) {
    <span class="cycle-function">return</span> <span class="value">user</span>.<span class="value">age</span> &gt;= <span class="property">this</span>.<span class="value">minAge</span> && <span class="value">user</span>.<span class="value">age</span> &lt; <span class="property">this</span>.<span class="value">maxAge</span>;
  }
};

<span class="property">const</span> <span class="value">users</span> = [
  {<span class="value">age:</span> 16},
  {<span class="value">age:</span> 20},
  {<span class="value">age:</span> 23},
  {<span class="value">age:</span> 27},
];

<span class="property">const</span> <span class="value">soldiers</span> = <span class="value">users</span>.<span class="selector">filter</span>(<span class="value">army</span>.<span class="selector">canJoin</span>, <span class="value">army</span>);
<span class="comment">//Можно добиться такого же эффекта если использовать стрелочную функцию, которая является более читаемой</span>
<span class="property">const</span> <span class="value">soldiers</span> = <span class="value">users</span>.<span class="selector">filter</span>(<span class="value">user</span> <span class="cycle-function">=&gt;</span> <span class="value">army</span>.<span class="selector">canJoin</span>(<span class="value">user</span>));

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">soldiers</span>.<span class="value">length</span>); <span class="comment">// 2</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">soldiers</span>); <span class="comment">// { age: 20 } { age: 23 }</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">soldiers</span>[0].<span class="value">age</span>); <span class="comment">// 20</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">soldiers</span>[1].<span class="value">age</span>); <span class="comment">// 23</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Оператор расширения (...)</span>
<span class="comment">// Оператор ... можно использовать для того, чтобы сделать из массива список параметров:</span>
<span class="property">const</span> <span class="value">arr1</span> = [1, -2, 3, 4];
<span class="property">const</span> <span class="value">arr2</span> = [8, 3, -8, 1];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">Math</span>.<span class="selector">max</span>(1, ...<span class="value">arr1</span>, 2, ...<span class="value">arr2</span>, 25)); <span class="comment">// 25</span>

<span class="comment">// Или для слияния массивов:</span>
<span class="property">const</span> <span class="value">arr1</span> = [1, 3, 5];
<span class="property">const</span> <span class="value">arr2</span> = [2, 4, 6];

<span class="property">const</span> <span class="value">merged</span> = [0, ...<span class="value">arr1</span>, 1, ...<span class="value">arr2</span>];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">merged</span>); <span class="comment">// 0, 1, 3, 5, 1, 2, 4, 6</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// При помощи оператора расширения можно превратить строку в массив:</span>
<span class="comment">// Это происходит потому что оператор расширения под капотом использует цикл for of</span>

<span class="property">const</span> <span class="value">str</span> = <span class="string">'Привет'</span>;

<span class="value">console</span>.<span class="selector">log</span>([...<span class="value">str</span>]); <span class="comment">// ['П', 'р', 'и', 'в', 'е', 'т',]</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Array.from()</span>
<span class="comment">// Превращает строку в массив, метод также работает с тем, что возвращает Set, если это масивоподобный объект</span>

<span class="property">const</span> <span class="value">str</span> = <span class="string">"abc"</span>

<span class="property">const</span> <span class="value">array</span> = <span class="object">Array</span>.<span class="selector">from</span>(<span class="value">str</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">array</span>); <span class="comment">// ["a", "b", "c"]</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Деструктуризирующее присваивание</span> -
        это специальный синтаксис, который позволяет нам "распаковать" массивы
        или объекты в несколько переменных, так как иногда они более удобны.
        Деструктуризация применяется тогда, когда нам из массива или объекта
        необходимо получить один элемент.
      </p>
      <p class="text">
        <span class="text-offset">Деструктуризация массива</span>
      </p>
      <p class="text">
        Ниже пример того, как массив можно деструктуризовать на переменные
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// У нас есть массив в котором присутствует имя и фамилия</span>
<span class="property">const</span> <span class="value">arr</span> = [<span class="string">"John"</span>, <span class="string">"Smith"</span>];

<span class="comment">// Деструктурирующее присваивание записывает</span>
<span class="comment">// let firstName = arr[0]; (John)</span>
<span class="comment">// let surname = arr[1]; (Smith)</span>
<span class="property">const</span> [<span class="value">firstName</span>, <span class="value">surname</span>] = <span class="value">arr</span>;

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">firstName</span>); <span class="comment">// John</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">surname</span>); <span class="comment">// Smith</span>

<span class="comment">// Мы можем подвергнуть деструктуризации любой перебираемый объект, не только массивы</span>
<span class="property">const</span> [<span class="value">a</span>, <span class="value">b</span>, <span class="value">c</span>] = <span class="string">"abc"</span>;

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Деструктурирующее присваивание отлично работает в связке с методами массива возвращающими массив</span>

<span class="property">const</span> <span class="value">str</span> = <span class="string">'John Smith'</span>;
<span class="property">const</span> [<span class="value">firstName</span>, <span class="value">surname</span>] = <span class="value">str</span>.<span class="selector">split</span>(<span class="string">' '</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">firstName</span>, <span class="value">surname</span>); <span class="comment">// John Smith</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Нежелательные элементы, при деструктуризации, могут быть отброшены с помощью дополнительной запятой</span>

<span class="property">const</span> [<span class="value">firstName</span>, , <span class="value">title</span>] = [<span class="string">'Julius'</span>, <span class="string">'Caesar'</span>, <span class="string">'Consul'</span>, <span class="string">'of the Roman Republic'</span>]

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">firstName</span>, <span class="value">title</span>); <span class="comment">// Julius Consul</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// При помощи деструктурирующего присваивания можно быстро поменять значения двух переменных друг с другом</span>

<span class="property">let</span> <span class="value">admin</span> = <span class="string">'John'</span>;
<span class="property">let</span> <span class="value">guest</span> = <span class="string">'Pete'</span>;

<span class="comment">// Давайте поменяем местами значения:</span>
[<span class="value">admin</span>, <span class="value">guest</span>] = [<span class="value">guest</span>, <span class="value">admin</span>];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">admin</span>, <span class="value">guest</span>); <span class="comment">// </span> Pete John - Успешно изменено!

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Используя оператор остаточные параметры ( ... ), мы можем деструктуризовать массив строк, распределив их по переменным:</span>
<span class="comment">// Тут нужно помнить о правиле, что остаточные переменные объявляются последними</span>
<span class="property">const</span> [<span class="value">value1</span>, <span class="value">value2</span>, ...<span class="value">value3</span>] = [<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"watermelon"</span>, <span class="string">"grapes"</span>];

<span class="comment">// value3 - это массив начиная с третьего</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">value1</span>); <span class="comment">// apple</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">value2</span>); <span class="comment">// orange</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">value3</span>[0]); <span class="comment">// watermelon</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">value3</span>[1]); <span class="comment">// grapes</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Можно указывать значения по умолчанию и функции в присваивании, но стоит отметить что значения по умолчанию и функции активируются только если в массиве справа не будет значения для данных переменных</span>
<span class="property">const</span> [<span class="value">name</span> = <span class="string">"Anonymous"</span>, <span class="value">surname</span> = <span class="selector">prompt</span>(<span class="string">"Surname?"</span>)] = [<span class="string">"John"</span>];

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">name</span>); <span class="comment">// John, тк в массиве спарава для name было значение, иначе было бы знчение по умолчанию - Anonymous</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">surname</span>); <span class="comment">// Результат ввода в prompt</span>
</code>
</pre>
      </div>
    </div>
    <!-- Block 04 end -->
    <!-- Block 05 start -->
    <div class="b05 block">
      <p class="title">
        <span class="title-number">05.</span> Циклы while, do while, for, for
        of, for in и операторы continue и break.
      </p>
      <p class="text">
        <span class="text-offset">Циклы</span> - это программы, позволяющие
        выполнять действия определенное количество раз.
      </p>
      <p class="text">
        Ниже будут представлены примеры использования циклов.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Цикл while - выполняет блок кода до тех пор, пока условие в цикле while = true</span>
<span class="property">let</span> <span class="value">isFile</span> = 50;

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">`Началась загрузка файла весом</span> <span class="property">${</span><span class="value">isFile</span><span class="property">}</span> <span class="string">мб`</span>);

<span class="cycle-function">while</span> (<span class="value">isFile</span> &gt; 0) {
  <span class="value">isFile</span> -= 10;
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">`Вы загрузили 10 мб, осталось</span> <span class="property">${</span><span class="value">isFile</span><span class="property">}</span> <span class="string">мб`</span>);
}

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Файл успешно загружен"</span>);
<span class="comment">// Началась загрузка файла весом 50 мб
   Вы загрузили 10 мб, осталось 40 мб
   Вы загрузили 10 мб, осталось 30 мб
   Вы загрузили 10 мб, осталось 20 мб
   Вы загрузили 10 мб, осталось 10 мб
   Вы загрузили 10 мб, осталось 0 мб
   Файл успешно загружен</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Цикл do while похож на while, отличие в том, что условие проверяется после прохождения каждой итерации, но при этом каждая итерация будет выполнена</span>
<span class="comment">// В пример приведем игру русская рулетка, 1 патрон 5и зарядный барабан, вероятность выстрела 20%</span>
<span class="cycle-function">do</span> {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Нажимаем на курок"</span>);
} <span class="cycle-function">while</span> (<span class="value">Math</span>.<span class="selector">random</span>() &gt; 0.2);

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Выстрел"</span>);

------------------------------------------------------------------------------------------------------------
<span class="comment">// Цикл for для записи чисел Фибоначи в массив.</span>
<span class="comment">// Числа Фибоначи - это результат сложения следующего числа с предыдущим, 0 + 1 = 1, 1 + 1 = 2 и тд.</span>
<span class="property">const</span> <span class="value">fibo</span> = [0, 1];

<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">i</span> = 1; <span class="value">i</span> &lt; 10; ++<span class="value">i</span>) {
  <span class="value">fibo</span>.<span class="selector">push</span>(<span class="value">fibo</span>[<span class="value">i</span>] + <span class="value">fibo</span>[<span class="value">i</span> - 1]);
}

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">fibo</span>); <span class="comment">// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Бесконечный цикл который заставит программу зависнуть (не проверяйте!).</span>
<span class="cycle-function">for</span> (;;) <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Меня не остановить!"</span>);

------------------------------------------------------------------------------------------------------------
<span class="comment">// Цикл который завершится на любой итерации с вероятностью 10%.</span>
<span class="cycle-function">for</span> (;<span class="value">Math</span>.<span class="selector">random</span>() &gt;= 0.1;) <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Еще раз!"</span>);

------------------------------------------------------------------------------------------------------------
<span class="comment">// Цикл for of позволяет передавать значение элемента массива, переменной находящейся слева от of (переменная i), те. присваивать ей то же значение что и у элемента массива.</span>
<span class="comment">// В данном примере у нас есть массив и цикл, который, в каждой итерации выводит один элемент из массива:</span>
<span class="property">const</span> <span class="value">fruits</span> = [<span class="string">"Яблоко"</span>, <span class="string">"Апельсин"</span>, <span class="string">"Груша"</span>, <span class="string">"Банан"</span>, <span class="string">"Манго"</span>];

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Сегодня я съел:"</span>);

<span class="cycle-function">for</span> (<span class="property">let</span> <span class="value">i</span> <span class="property">of</span> <span class="value">fruits</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">fruit</span>);
}
<span class="comment">// "Сегодня я съел:"
   "Яблоко"
   "Апельсин"
   "Груша"
   "Банан"
   "Манго"</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Не рекомендуется к использованию для массивов, тк работает медленнее чем цикл for of!!!</span>
<span class="comment">// Цикл for in похож на принцип работы цикла for of, отличие лишь в том что переменная, которую мы указываем в цикле слева (i), принимает не значение элемента массива, а значение его индекса, те порядкового номера.</span>
<span class="comment">// В данном примере у нас есть массив в котором есть список студентов и нам нужно вывести их рейтинг:</span>
<span class="property">const</span> <span class="value">rating</span> = [<span class="string">"Катя"</span>, <span class="string">"Вася"</span>, <span class="string">"Маша"</span>, <span class="string">"Петя"</span>, <span class="string">"Лена"</span>];

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Рейтинг студентов:"</span>);

<span class="cycle-function">for</span> (<span class="property">let</span> <span class="value">i</span> <span class="property">in</span> <span class="value">rating</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">`</span><span class="property">${</span><span class="selector">parseInt</span>(<span class="value">i</span>) + 1<span class="property">}</span> <span class="string">место:</span> <span class="property">${</span><span class="value">rating</span>[<span class="value">i</span>]<span class="property"><span class="string">`</span>}</span>; <span class="comment">// parseInt здесь используется чтобы превратить строку в число, тк переменная указанная перед in принимает строковое значение</span>
}
<span class="comment">// "Рейтинг студентов:"
   "1 место: Катя"
   "2 место: Вася"
   "3 место: Маша"
   "4 место: Петя"
   "5 место: Лена"</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Оператор continue - используется когда нам нужно прервать текущую итерацию и переходить к следующей.</span>
<span class="comment">// В данном примере мы играем в карточную игру, в массиве лежат карты и мы, при помощи цикла решаем какие карты взять и какие положить обратно. Берем мы только королей и тузов.</span>
<span class="property">const</span> <span class="value">cards</span> = [<span class="string">"2"</span>, <span class="string">"Король"</span>, <span class="string">"Туз"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"Король"</span>, <span class="string">"Дама"</span>];

<span class="property">const</span> <span class="value">hand</span> = [];

<span class="cycle-function">for</span> (<span class="property">let</span> <span class="value">card</span> <span class="property">of</span> <span class="value">cards</span>) {
  <span class="cycle-function">if</span> (<span class="value">card</span> !== <span class="string">"Король"</span> && <span class="value">card</span> !== <span class="string">"Туз"</span>) <span class="cycle-function">continue</span>; <span class="comment">// Если if = false, то continue не выполняется</span>
  <span class="value">hand</span>.<span class="selector">push</span>(<span class="value">card</span>);
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">`Карта</span> <span class="property">${</span><span class="value">card</span><span class="property">}</span> <span class="string">добавлена в руку`</span>;
}

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Карты в руке:"</span>, <span class="value">hand</span>);
<span class="comment">// Карта Король добавлена в руку
   Карта Туз добавлена в руку
   Карта Король добавлена в руку
   Карты в руке: [ "Король", "Туз", "Король" ]</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Оператор break - используется когда нам нужно выйти из цикла при выполнении какого-либо условия</span>
<span class="comment">// Например, у нас есть колода карт, как только мы вытягиваем из нее даму, цикл завершается, либо мы проверяем все карты и там не оказывается дам</span>
<span class="property">const</span> <span class="value">cards</span> = [<span class="string">"2"</span>, <span class="string">"Король"</span>, <span class="string">"Дама"</span>, <span class="string">"Туз"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"Король"</span>];

<span class="property">let</span> <span class="value">found</span> = <span class="property">false</span>; <span class="comment">// Переменная отвечающая за то, нашлась ли карта, по умолчанию false, как мы видим ниже, после того как дама нашлась, переменная принимает значение true и уже от этого будет зависеть конечное сообщение</span>

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Ищем карту в колоде..."</span>);

<span class="cycle-function">for</span> (<span class="property">let</span> <span class="value">card</span> <span class="property">of</span> <span class="value">cards</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">`Из колоды вытянута карта</span> <span class="property">${</span><span class="value">card</span><span class="property">}</span><span class="string">`</span>);

  <span class="cycle-function">if</span> (<span class="value">card</span> === <span class="string">"Дама"</span>) {
    <span class="property">let</span> <span class="value">found</span> = <span class="property">true</span>;
    <span class="cycle-function">break</span>;
  }
}

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">found</span> ? <span class="string">"Вы нашли даму!"</span> : <span class="string">"В колоде нет дам"</span>); <span class="comment">// Если в колоде не было дам, уловие выдало бы нам второй ответ</span>
<span class="comment">// Ищем карту в колоде...
   Из колоды вытянута карта 2
   Из колоды вытянута карта Король
   Из колоды вытянута карта Дама
   Вы нашли даму!</span>
</code>
</pre>
      </div>
    </div>
    <!-- Block 05 end -->
    <!-- Block 06 start -->
    <div class="b06 block">
      <p class="title"><span class="title-number">06.</span> Объекты.</p>
      <p class="text">
        <span class="text-offset">Объект</span> - это тип данных позволяющий
        объединить множество элементов в один, объекты, в соновном, существуют
        чтобы предоставлять сущности реального мира, полозиватели, заказы и
        тд. Объекты, в отличие от примитивных значений, таких как строка или
        число, хранят в себе лишь ссылку на сам объект. Поэтому при
        копировании объекта в другую переменную, копируется лишь ссылка на
        него, но сам объект не дублируется.
      </p>
      <p class="text">
        Ключи в объектах автоматически преобразовываются в строки, поэтому
        ключ (имя) со значением 1, будет преобразован в строку "1"
      </p>
      <p class="text">
        Ниже будут представлены примеры взаимодействия с объектами и их
        синтаксис.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Синтаксис объекта выглядит следующим образом:</span>
<span class="property">const</span> <span class="value">objectName</span> = {
  <span class="value">propertyName1:</span> <span class="value">value1</span>,
  <span class="value">propertyName2:</span> <span class="value">value2</span>,
  <span class="value">...</span>
};

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">objectName</span>.<span class="value">propertyName1</span>); <span class="comment">// Вызов нужного нам свойства из объекта</span>
<span class="comment">// value1</span>

<span class="comment">// Возможности объекта:</span>
<span class="comment">// Переменные так же могут быть получены в ходе пользовательского ввода и присваиваться либо к имени, либо к значению</span>
<span class="property">const</span> <span class="value">name</span> = <span class="string">"John"</span>;
<span class="property">const</span> <span class="value">surname</span> = <span class="string">"Smith"</span>;
<span class="property">const</span> <span class="value">patronymic</span> = <span class="string">"Johnson"</span>;

<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="value">name</span>, <span class="comment">// Можно использовать уже объявленные переменные</span>
  <span class="value">surname</span>, <span class="comment">// Если значения и названия записанных в них переменных совпадают, то значения можно не писать</span>
  <span class="value">middleName:</span> <span class="value">patronymic</span>,
  <span class="value">birthDate:</span> { <span class="value">year:</span> 1991, <span class="value">month:</span> 3, <span class="value">day:</span> 3 }, <span class="comment">// Можно использовать другие объекты</span>
  <span class="value">occupation:</span> <span class="string">"Backend developer"</span>, <span class="comment">// Можно использовать строки в значении</span>
  <span class="value">married:</span> <span class="property">true</span>, <span class="comment">// Можно использовать boolean операторы</span>
  <span class="string">"property with spaces"</span><span class="value">:</span> <span class="property">null</span>, <span class="comment">// Если в названии переменной необходимо использовать спец. символы или пробелы, то названия задаются в виде строк, но таких свойств лучше избегать, тк с ними не удобно работать  </span>
  <span class="string">"property.with.dots"</span><span class="value">:</span> <span class="property">null</span>,
};

<span class="comment">// Добавление новых свойств:</span>
<span class="value">user</span>.<span class="value">education</span> = <span class="string">"МГУ"</span>;

<span class="comment">// Изменение текущих свойств:</span>
<span class="value">user</span>.<span class="value">occupation</span> = <span class="string">"Unemployed"</span>;

<span class="comment">// Изменение текущих строковых свойств и обращение к ним, происходит путем заключения их в квадратные скобки:</span>
<span class="comment">// Также, квадратные скобки позволяют взять ключ из переменной, что не позволяет делать точка</span>
<span class="value">user</span>[<span class="string">"property with spaces"</span>] = 33;
<span class="value">user</span>[<span class="string">"property.with.dots"</span>] = 33;

<span class="comment">// Удаление текущих свойств:</span>
<span class="property">delete</span> <span class="value">user</span>.<span class="value">education</span>;
<span class="property">delete</span> <span class="value">user</span>[<span class="string">"property with spaces"</span>];

<span class="comment">// Получение значения свойств:</span>
<span class="property">const</span> <span class="value">getName</span> = <span class="value">user</span>.<span class="value">name</span>; <span class="comment">// John</span>
<span class="property">const</span> <span class="value">getBirthYear</span> = <span class="value">user</span>.<span class="value">birthDate</span>.<span class="value">year</span>; <span class="comment">// 1991</span>
<span class="property">const</span> <span class="value">getEducation</span> = <span class="value">user</span>.<span class="value">education</span>; <span class="comment">// Значения удаленных или несуществующих свойств = undefined</span>
<span class="property">const</span> <span class="value">getEmptyObj</span> = <span class="value">emptyObj</span>.<span class="value">name</span>;
<span class="property">const</span> <span class="value">getEmptyProperty</span> = <span class="value">emptyObj</span>.<span class="value">emptyProperty</span>;

<span class="comment">// Пустой объект - нужен тогда, когда набор свойств объекта неизвестен и он наполняется во время работы программы</span>
<span class="comment">// Существует два вида синтаксиса объявления пустых массивов:</span>
<span class="property">const</span> <span class="value">emptyObj</span> = <span class="property">new</span> <span class="object">Object</span>(); <span class="comment">// Конструктор оъекта</span>
<span class="property">const</span> <span class="value">emptyObj</span> = {}; <span class="comment">// Литерал объекта</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Объекты можно объединять в один при помощи оператора spread, записывается в виде трех точек "..."</span>
<span class="comment">// Оператор ... принимает на себя две функции в зависимости от того где он вызывается: оператор расширения - если встретился в вызове функции и оператор остаточных параметров - если он в аргументах функции</span>
<span class="comment">// Допустим у нас есть объекты в которых содержится информация о детлях компьютера и нам нужно объединить ее в один объект:</span>
<span class="comment">// Если в объекте присутсвуют свойства с одинаковым названием, то при объединении, добавится то свойство, которое объявлено последним</span>
<span class="property">const</span> <span class="value">motherBoard</span> = { Information about mother board };
<span class="property">const</span> <span class="value">cpu</span> = { Information about cpu };
<span class="property">const</span> <span class="value">videoCard</span> = { Information about video card };
<span class="property">const</span> <span class="value">ram</span> = { Information about ram };

<span class="comment">// Создаем объект в котором мы объединим все составляющие:</span>
<span class="property">const</span> <span class="value">computer</span> = {
  <span class="value">price:</span> 100000,
  ...<span class="value">motherBoard</span>,
  ...<span class="value">cpu</span>,
  ...<span class="value">videoCard</span>,
  ...<span class="value">ram</span>,
};

<span class="comment">// Аналогичным образом работает метод Object.assign(currentObj, src1, src2, ... srcN);</span>
<span class="comment">// Где currentObj - Объект в который мы хотим объединить все src</span>
<span class="property">const</span> <span class="value">computer</span> = {
  <span class="value">price:</span> 100000
};

<span class="object">Object</span>.<span class="selector">assign</span>(<span class="value">computer</span>, <span class="value">motherBoard</span>, <span class="value">cpu</span>, <span class="value">videoCard</span>, <span class="value">ram</span>);

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// <span class="console-chapter">Object.keys(obj)</span> - Позволяет получить все свойства (ключи) объекта</span>
<span class="comment">// <span class="console-chapter">Object.values(obj)</span> - Позволяет получить все значения объекта</span>
<span class="comment">// <span class="console-chapter">Object.entries(obj)</span> - Позволяет получить свойства вместе со значениями</span>

<span class="property">const</span> <span class="value">computer</span> = {
  <span class="value">price:</span> 100000,
  <span class="value">chipset:</span> <span class="string">"AMD X570"</span>,
  <span class="value">videoCardModel:</span> <span class="string">"NVidia GeForce GTX 1060"</span>,
  <span class="value">videoMemory:</span> 4096,
  <span class="value">ramType:</span> <span class="string">"DDR4"</span>,
};

<span class="value">console</span>.<span class="selector">log</span>(<span class="object">Object</span>.<span class="selector">keys</span>(<span class="value">computer</span>)); <span class="comment">// [ price, chipset, videoCardModel, videoMemory, ramType ]</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="object">Object</span>.<span class="selector">values</span>(<span class="value">computer</span>)); <span class="comment">// [ 100000, AMD X570, NVidia GeForce GTX 1060, 4096, DDR4 ]</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="object">Object</span>.<span class="selector">entries</span>(<span class="value">computer</span>));
<span class="comment">// [ price, 100000 ],
   [ chipset, AMD X570 ],
   [ videoCardModel, NVidia GeForce GTX 1060 ],
   [ videoMemory, 4096 ],
   [ ramType, DDR4 ]</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Трансформация объектов</span>
<span class="comment">// У объектов нет встроенных методов, таких как map или filter</span>
<span class="comment">// но если мы хотим их использовать, необходимо применить к объекту Object.entries с последующим вызовом Object.fromEntries</span>
<span class="comment">// Например, у нас есть объект с ценами которые мы хотим удвоить</span>

<span class="property">const</span> <span class="value">prices</span> = {
  <span class="value">Apple:</span> 1,
  <span class="value">Orange:</span> 2,
  <span class="value">Banana:</span> 3,
};

<span class="property">const</span> <span class="value">doublePrices</span> = <span class="object">Object</span>.<span class="selector">fromEnties</span>(
  <span class="comment">// Преобразовываем в массив, затем map, затем fromEntries обратно объект</span>
  <span class="object">Object</span>.<span class="selector">enties</span>(<span class="value">prices</span>).<span class="selector">map</span>(([<span class="value">key</span>, <span class="value">value</span>]) =&gt; [<span class="value">key</span>, <span class="value">value</span> * 2]);
);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">doublePrices</span>.<span class="value">Banana</span>); <span class="comment">// 6</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// <span class="console-chapter">Оператор in</span> - Проверка существования свойства</span>
<span class="comment">// Оперотор in используется для проверки существования свойства в объекте:</span>
<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="value">age:</span> 30
};

<span class="value">console</span>.<span class="selector">log</span>(<span class="string">"name"</span> <span class="property">in</span> <span class="value">user</span>); <span class="comment">// true, обратите внимание что ключ записывается в кавычках</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment">// Цикл for in - используется для перебора всех свойств объекта</span>
<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="value">age:</span> 30
};

<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">prop</span> <span class="property">in</span> <span class="value">user</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">prop</span>); <span class="comment">// name age - выводятся ключи объекта</span>
}

<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">prop</span> <span class="property">in</span> <span class="value">user</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>[<span class="value">prop</span>]); <span class="comment">// John 30 - выводятся значения объекта</span>
}

------------------------------------------------------------------------------------------------------------
<span class="comment">// Упорядочивание свойств объекта</span>
<span class="comment">// Наш объект содержит коды телефонных номеров</span>
<span class="property">const</span> <span class="value">number</span> = {
  <span class="string">"49"</span>: <span class="string">"Германия"</span>,
  <span class="string">"41"</span>: <span class="string">"Швейцария"</span>,
  <span class="string">"44"</span>: <span class="string">"Великобритания"</span>,
  <span class="string">"1"</span>: <span class="string">"США"</span>,
};

<span class="comment">// Мы предполагаем, что номера будут выводиться сверху вниз, но это происходит не так</span>
<span class="comment">// При сортировке, ключи, если их имена являются цифры, при переборе выводятся в порядке возрастания, от большего к меньшему, пример:</span>
<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">prop</span> <span class="property">in</span> <span class="value">user</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">prop</span>); <span class="comment">// 1 41 44 49</span>
}
<span class="comment">// Это происходит потому что свойства с целочисленными ключами, сортируются по возрастанию</span>
<span class="comment">// Целочисленное свойство - это строка, которая может быть преобразована в целое число и обратно без изменений</span>
<span class="comment">// Это можно решить добавив + перед каждой цифрой</span>
<span class="comment">// "49" после преобразования в число и обратно = "49", а "+49" после преобразования в число и обратно будет = "49", соответственно +49 не целочисленное свойство</span>
<span class="property">const</span> <span class="value">number</span> = {
  <span class="string">"+49"</span>: <span class="string">"Германия"</span>,
  <span class="string">"+41"</span>: <span class="string">"Швейцария"</span>,
  <span class="string">"+44"</span>: <span class="string">"Великобритания"</span>,
  <span class="string">"+1"</span>: <span class="string">"США"</span>,
};

<span class="comment">// Номера выводятся сверху вниз, как мы и предполагаем!</span>
<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">prop</span> <span class="property">in</span> <span class="value">user</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(+<span class="value">prop</span>); <span class="comment">// 49 41 44 1, обратите внимание, что мы поставили + перед вызовом, для того чтобы в вызове избавиться от плюсов в ключах</span>
}

------------------------------------------------------------------------------------------------------------
<span class="comment">// Как мы знаем, переменные хранят в себе только ссылку на объект, и при копировании, дублируется ссылка, но не сам объект</span>
<span class="comment">// Из-за этого мы можем получать вот такие неприятные моменты, когда объект был изменен по скопированной ссылке:</span>
<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="value">age:</span> 30
};

<span class="property">const</span> <span class="value">clone</span> = <span class="value">user</span> <span class="comment">// Скопировали ссылку на объект хранившуюся в переменной user</span>

<span class="value">clone</span>.<span class="value">name</span> = <span class="string">"Pete"</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>.<span class="value">name</span>); <span class="comment">// Pete, изменения по скопированной ссылке затронули сам объект</span>

<span class="comment">// Полного копирования объекта можно добиться с использованием structuredClone(), который позволяет сделать полную копию объекта</span>
<span class="property">const</span> <span class="value">clone</span> = <span class="selector">structuredClone</span>(<span class="value">user</span>); <span class="comment">// Полное копирование объекта user и присваивание копии в переменную clone</span>

<span class="value">clone</span>.<span class="value">name</span> = <span class="string">"Pete"</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">clone</span>.<span class="value">name</span>); <span class="comment">// Pete</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>.<span class="value">name</span>); <span class="comment">// John, изменения не затронули объект находящийся по ссылке в переменной user</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Флаги и дескрипторы свойств</span>
      </p>
      <p class="text">
        <span class="text-offset">Флаги свойства</span> - Это долнительные атрибуты, позволяющие настраивать
        определённое свойство. Они нужны для того, чтобы заблокировать наш объект не позволяя изменять или редактировать
        его свойства.
      </p>
      <p class="text">
        Флаги бывают трёх типов:
      </p>
      <ul class="list">
        <li class="item">
          <span class="highlight">writable</span> - если true, свойство можно изменить, иначе оно только для чтения.
        </li>
        <li class="item">
          <span class="highlight">enumerable</span> - если true, свойство перечисляется в циклах, в противном случае
          циклы его игнорируют.
        </li>
        <li class="item">
          <span class="highlight">configurable</span> - если true, свойство можно удалить, а эти атрибуты можно
          изменять, иначе этого делать нельзя.
        </li>
      </ul>
      <p class="text">
        Эти атрибуты обычно скрыты. Когда мы создаём свойство "обычным способом", все они имеют значение true. Но мы
        можем изменить их в любое время.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Синтаксис для получения текущего значения свойства объекта:</span>

<span class="property">const</span> <span class="value">descriptor</span> = <span class="object">Object</span>.<span class="selector">getOwnProppertyDescriptor</span>(<span class="value">obj</span>, <span class="string">'propertyName'</span>);

<span class="comment">// obj - Объект, из которого мы получаем информацию.</span>
<span class="comment">// propertyName - Имя свойства.</span>
<span class="comment">// Возвращаемое значение - это объект, так называемый "дескриптор свойства": он содержит значение свойства и все его флаги.</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Например, получим значение свойства name и все его флаги:</span>

<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">'John'</span>,
};

<span class="property">const</span> <span class="value">descriptor</span> = <span class="object">Object</span>.<span class="selector">getOwnProppertyDescriptor</span>(<span class="value">user</span>, <span class="string">'name'</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">descriptor</span>);
<span class="comment">{
  "name": 'John',
  "writable": true,
  "enumerable": true,
  "configurable": true
}</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="comment"><span class="console-chapter">Object.defineProperty(obj, 'propertyName', descriptor)</span> - Позволяет изменить флаги.</span>

<span class="comment">// obj, propertyName - Объект и его свойство, для которого нужно применить дескриптор.</span>
<span class="comment">// descriptor - Применяемый дескриптор.</span>
<span class="comment">// Если свойство существует, defineProperty обновит его флаги.</span>
<span class="comment">// В противном случае метод создаёт новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение false.</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// В данном примере мы сделаем свойство user.name только для чтения:</span>

<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">'John'</span>,
};

<span class="object">Object</span>.<span class="selector">defineProperty</span>(<span class="value">user</span>, <span class="string">'name'</span>, {
  <span class="value">writable:</span> <span class="property">false</span>,
});

<span class="value">user</span>.<span class="value">name</span> = <span class="string">'Pete'</span>; <span class="comment">// Невозможно изменить свойсвтво, тк writable: false</span>
<span class="comment">// В режиме 'use strict', подобная попытка вызвала бы ошибку, без него, действие просто игнорируется</span>

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user.name</span>); <span class="comment">// John</span>

<span class="comment">// Но мы всё ещё можем изменить имя пользователя, если обновим флаг writable новым вызовом defineProperty.</span>
<span class="object">Object</span>.<span class="selector">defineProperty</span>(<span class="value">user</span>, <span class="string">'name'</span>, {
  <span class="value">writable:</span> <span class="property">true</span>,
});

<span class="value">user</span>.<span class="value">name</span> = <span class="string">'Pete'</span>;

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user.name</span>); <span class="comment">// Pete - имя изменилось</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Неконфигурируемые свойства, configurable: false</span>
<span class="comment">// Неконфигурируемое свойство не может быть удалено, его атрибуты не могут быть изменены.</span>
<span class="comment">// Определение свойства как неконфигурируемого и добавление к нему writable: false - полностью блокирует его изменение из вне даже при помощи defineProperty.</span>

<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">'John'</span>,
};

<span class="object">Object</span>.<span class="selector">defineProperty</span>(<span class="value">user</span>, <span class="string">'name'</span>, {
  <span class="value">writable:</span> <span class="property">false</span>,
  <span class="value">configurable:</span> <span class="property">false</span>,
});

<span class="value">user</span>.<span class="value">name</span> = <span class="string">'Pete'</span>; <span class="comment">// Невозможно - writable: false</span>

<span class="object">Object</span>.<span class="selector">defineProperty</span>(<span class="value">user</span>, <span class="string">'name'</span>, {
  <span class="value">writable:</span> <span class="property">true</span>,
  <span class="value">configurable:</span> <span class="property">true</span>,
}); <span class="comment">// Ошибка - невозможно переопределить свойство</span>

<span class="property">delete</span> <span class="value">user</span>.<span class="value">name</span>; <span class="comment">// Невозможно - configurable: false</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Методы объекта this</span>
      </p>
      <p class="text">
        <span class="text-offset">Метод this</span> - как и все методы, это
        функция которая является свойством объекта. Метод this используется
        для доступа к информации внутри объекта, но при этом он может
        находится и вне этого объекта, потому что this определяется во время
        вызова функции.
      </p>
      <p class="text">
        Стоит помнить один нюанс, объявляя методы в объекте, не стоит делать
        это с использованием стрелочных функций, тк у них нет своего
        собственного this. Вместо стрелочных функций, лучше использовать
        сокращенную запись которую вы увидите в первом примере ниже.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// this записывается следующим образом:</span>
<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="value">age:</span> 30,
  <span class="selector">getName</span>() {
    <span class="value">console</span>.<span class="selector">log</span>(<span class="property">this</span>.<span class="value">name</span>); <span class="comment">// Можно прочитать как "this - текущий объект.свойство name"</span>
  }
};

<span class="value">user</span>.<span class="selector">getName</span>();
<span class="comment">// John</span>
<span class="comment">// this - это тоже самое что и user.name, но с одним приемуществом, если мы решим перезаписать объект user, например admin = user, то user.name не приведет нас к нужному свойству, а this будет всегда отсылать нас к текущему объекту, даже если его название сменится</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// this не является фиксированным и может находится вне объекта</span>
<span class="property">const</span> <span class="value">user</span> = { <span class="value">name:</span> <span class="string">"John"</span> };
<span class="property">const</span> <span class="value">admin</span> = { <span class="value">name:</span> <span class="string">"Admin"</span> };

<span class="cycle-function">function</span> <span class="selector">getClient</span>() {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="property">this</span>.<span class="value">name</span>);
}

<span class="comment">// Используем одну и ту же функцию в двух объектах, добавляя её в каждый из объектов под свойством с названием "f":</span>
<span class="value">user</span>.<span class="value">f</span> = <span class="selector">getClient</span>;
<span class="value">admin</span>.<span class="value">f</span> = <span class="selector">getClient</span>;

<span class="comment">// Вызывая эти функции, мы получим разные результаты, тк мы добавили функцию getClient в разные объекты, где свойство с названием name имеет разные значения</span>
<span class="value">user</span>.<span class="selector">f</span>(); <span class="comment">// John (this == user)</span>
<span class="value">admin</span>.<span class="selector">f</span>(); <span class="comment">// Admin (this == user)</span>
<span class="value">admin</span>[<span class="string">"f"</span>](); <span class="comment">// Admin (Для доступа к объекту, нет разницы в использовании точки или квадратных скобок)</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Прототипное наследование</span>
      </p>
      <p class="text">
        В JavaScript объекты имеют специальное скрытое свойство [[Prototype]],
        которое либо равно null, либо ссылается на другой объект. Этот объект
        называется "прототип".
      </p>
      <p class="text">
        Когда мы хотим прочитать свойство из object, а оно отсутствует,
        JavaScript автоматически берёт его из прототипа. Одним из способов
        задать свойство [[Prototype]], является использование __proto__
      </p>
      <p class="text">У прототипного наследования есть три ограничения:</p>
      <ol class="list">
        <li class="item">
          Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы
          попытаемся назначить __proto__ по кругу.
        </li>
        <li class="item">
          Значение __proto__ может быть объектом или null. Другие типы
          игнорируются.
        </li>
        <li class="item">
          Может быть только один [[Prototype]]. Объект не может наследоваться
          от двух других объектов.
        </li>
      </ol>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Пример использования свойства __proto__</span>
<span class="comment">// Если мы ищем свойство в rabbit, а оно отсутствует, JavaScript автоматически берёт его из animal.</span>

<span class="property">const</span> <span class="value">animal</span> = {
  <span class="value">eats:</span> <span class="property">true</span>,
};

<span class="property">const</span> <span class="value">rabbit</span> = {
  <span class="value">jumps:</span> <span class="property">true</span>,
};

<span class="value">rabbit</span>.<span class="value">__proto__</span> = <span class="value">animal</span>;

<span class="comment">// Теперь мы можем найти оба свойства в rabbit</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">rabbit</span>.<span class="value">eats</span>); <span class="comment">// true</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">rabbit</span>.<span class="value">jumps</span>); <span class="comment">// true</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Цепочка прототипов может быть длиннее и включать в себя методы объекта:</span>

<span class="property">const</span> <span class="value">animal</span> = {
  <span class="value">eats:</span> <span class="property">true</span>,
  <span class="selector">walk</span>() {
    <span class="value">console</span>.<span class="selector">log</span>(<span class="string">"Animal walk"</span>);
  },
};

<span class="property">const</span> <span class="value">rabbit</span> = {
  <span class="value">jumps:</span> <span class="property">true</span>,
  <span class="value">__proto__:</span> <span class="value">animal</span>,
};

<span class="property">const</span> <span class="value">longEar</span> = {
  <span class="value">earLength:</span> 10,
  <span class="value">__proto__:</span> <span class="value">rabbit</span>,
};

<span class="comment">// walk взят из цепочки прототипов</span>
<span class="value">longEar</span>.<span class="selector">walk</span>();
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">longEar</span>.<span class="value">jumps</span>); <span class="comment">// true (из rabbit)</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Конструктор, оператор new</span>
      </p>
      <p class="text">
        Обычный синтаксис объекта { ... }, позволяет нам создавать только один
        объект, в случае же, если нам нужно создать много похожих объектов,
        сделать это можно при помощи функции-конструктора и оператора new.
      </p>
      <p class="text">
        Функции-конструкторы являются обычными функциями, но есть два правила:
      </p>
      <ol class="list">
        <li class="item">
          Имя функции-конструктора должно начинаться с большой буквы.
        </li>
        <li class="item">
          Функция-конструктор должна выполняться только с помощю оператора
          new. Такой вызов подразумевает создание пустого this вначале и
          возврат заполненного в конце.
        </li>
      </ol>
      <p class="text">
        Основное приемущество функций-конструкторов и оператора new в том, что
        при необходимости мы можем вызывать функцию new User("Put user name")
        и создавать новых пользователей, такая запись куда более читаемая чем
        литеральная запись объекта. Это и является основной целью
        функций-конструкторов - реализовать код для создания однотипных
        объектов.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Когда функция вызывается как new User(), происходит следующее:</span>
<span class="comment">// 1. Создаётся новый пустой объект и он присваивается this (закомментировано в коде)</span>
<span class="comment">// 2. Выполняется тело функции, к this добавляются новые свойства</span>
<span class="comment">// 3. Возвращается значение this</span>

<span class="cycle-function">function</span> <span class="object">User</span>(<span class="value">name</span>) {
  <span class="comment">// 1. this = {}; (неявно)</span>

  <span class="comment">// 2. Добавляет свойства к this</span>
  <span class="property">this</span>.<span class="value">name</span> = <span class="value">name</span>;
  <span class="property">this</span>.<span class="value">isAdmin</span> = false;

  <span class="comment">// 3. return this; (неявно)</span>
}

<span class="property">const</span> <span class="value">user</span> = <span class="property">new</span> <span class="object">User</span>(<span class="string">"John"</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>.<span class="value">name</span>); <span class="comment">// John</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>.<span class="value">isAmin</span>); <span class="comment">// false</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Создание методов в конструкторе</span>
<span class="comment">// Как и в обычном объекте, коструктор позволяет нам создавать методы - свойства объекта представляющие из себя функцию</span>

<span class="cycle-function">function</span> <span class="object">User</span>(<span class="value">name</span>) {

  <span class="property">this</span>.<span class="value">name</span> = <span class="value">name</span>;

  <span class="property">this</span>.<span class="value">sayHi</span> = <span class="cycle-function">function</span>() {
    <span class="value">console</span>.<span class="selector">log</span>(<span class="string">`</span><span class="string">Hello! My name is </span><span class="property">${</span><span class="property">this</span>.<span class="value">name</span><span class="property">}</span><span class="string">!`</span>);
  }
}

<span class="property">const</span> <span class="value">user</span> = <span class="property">new</span> <span class="object">User</span>(<span class="string">"John"</span>);

<span class="value">user</span>.<span class="selector">sayHi</span>(); <span class="comment">// Hello! My name is John!</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Классы</span>
      </p>
      <p class="text">
        Класс - это конструкция позволяющая создавать много объектов одного
        вида, она похожа на
        <span class="highlight">new Function</span> (выше), но в современном
        JavaScript есть более продвинутая конструкция, которая называется
        классы, и которая предоставляет новые возможности для объектно
        ориентированного программирования (ООП). К тому же, классы работают не
        совсем так же как new Function, потому что класс создает не объект, а
        функцию, ее код берется из constructor() {}, если же его нет, то
        функция будет пустой.
      </p>
      <p class="text">Класс является разновидностью функции</p>
      <p class="text">Особенности которые присущи классам:</p>
      <ul class="list">
        <li class="item">
          Наличие функции constructor() - которая является обязательной и
          позволяет инициализировать объект
        </li>
        <li class="item">Отсутствие запятых между методами</li>
      </ul>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Синтаксис class:</span>

<span class="property">class</span> <span class="object">MyClass</span> {
  <span class="comment">// Методы класса</span>
  <span class="property">constructor</span>() { ... }
  <span class="selector">method1</span>() { ... }
  <span class="selector">method2</span>() { ... }
  <span class="selector">method3</span>() { ... }
};

<span class="comment">// Данный вызов создаст новый объект со всеми перечисленными методами</span>
<span class="property">const</span> <span class="value">createObject</span> = <span class="property">new</span> <span class="object">MyClass</span>();

------------------------------------------------------------------------------------------------------------
<span class="comment">// Подробнее о constructor() {...}</span>
<span class="comment">// Когда вызывается new User("John")</span>
<span class="comment">// 1. Создается новый объект</span>
<span class="comment">// 2. constructor запускается с заданным аргументом и сохраняет его в this.name</span>
<span class="comment">// 3. На данном этапе мы можем взаимодействовать с объектом, например вызывать метод user.sayHi()</span>

<span class="property">class</span> <span class="object">User</span> {
  <span class="property">constructor</span>(<span class="value">name</span>) {
    <span class="property">this</span>.<span class="value">name</span> = <span class="value">name</span>;
  }

  <span class="selector">sayHi</span>() {
    <span class="value">console</span>.<span class="selector">log</span>(<span class="string">`</span><span class="string">Hello! My name is </span><span class="property">${</span><span class="property">this</span>.<span class="value">name</span><span class="property">}</span><span class="string">!`</span>);
  }
};

<span class="property">const</span> <span class="value">user</span> = <span class="property">new</span> <span class="object">User</span>(<span class="string">"John"</span>);
<span class="value">user</span>.<span class="selector">sayHi</span>(); <span class="comment">// Hello! My name is John!</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Свойства - геттеры и сеттеры</span>
      </p>
      <p class="text">
        Есть два типа свойств объекта:
      </p>
      <ul class="list">
        <li class="item">
          <span class="highlight">Свойства-данные (data properties)</span> - Все свойства, которые мы использовали до
          текущего момента, были свойствами-данными. Это такие свойства, в которых записано статичное значение и мы
          можем получить к ним доступ обратившись таким образом <span class="highlight">user.name</span>
        </li>
        <li class="item">
          <span class="highlight">Cвойства-аксессоры (accessor properties)</span> - Это функции, которые используются
          для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.
        </li>
      </ul>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Геттеры и Сеттеры:</span>

<span class="property">const</span> <span class="value">userJohn</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Опциональная цепочка ?.</span>
      </p>
      <p class="text">
        Опциональная цепочка - это безопасный способ доступа к вложенным
        объектам, даже если какое-либо из промежуточных свойств не существует.
        Опциональная цепочка - это не оператор в специальная синтаксическая
        конструкция, которая также работает с функциями и квадратными
        скобками.
      </p>
      <ol class="list">
        <li class="item">
          <span class="highlight">obj?.prop</span> - возвращает obj.prop если
          obj существует, иначе undefined.
        </li>
        <li class="item">
          <span class="highlight">obj?.[prop]</span> - возвращает obj[prop]
          если obj существует, иначе undefined.
        </li>
        <li class="item">
          <span class="highlight">obj.method?.()</span> - вызывает obj.method
          если obj.method существует, иначе undefined.
        </li>
      </ol>
      <p class="text">
        У нас есть объекты <span class="highlight">user</span>, в которых
        содержится вся информация о пользователях, внутри есть опциональный
        объект с данными адреса
        <span class="highlight">user.address.street</span>, если мы попытаемся
        обратиться к пользователю который не указывал улицу
        user.address.street, то получим ошибку, тк данного объекта внутри user
        нет.
      </p>
      <p class="text">
        В таком случае нам необходимо проверить существует ли нужное свойство
        в объекте, для этого нам понадобится проверка при помощи опциональной
        цепочки <span class="highlight">user.address?.street</span> - которая
        в случае, если в объекте user не окажется adress, просто выдаст
        undefined, что означало бы "улицы нет" и программа не упадет с
        ошибкой.
      </p>
      <p class="text">
        Опциональная цепочка <span class="highlight">?.</span> останавливает
        вычисление и возвращает undefined, если значение перед ?. равно
        undefined или null.
      </p>
      <p class="text">
        Опциональную цепочку следует использовать исходя из ее названия, там
        где свойство является опциональным и не обязательным, как в нашем
        примере свойство address. Эта мысль исходит из того, что если мы будем
        использовать такую запись user?.address?.street, но при этом мы
        подразумеваем что пользователь должен существовать, то получим
        undefined вместо ошибки, если пользователя не будет, что затруднит
        отладку. При этом user должна быть объявлена как const или let, тк
        опциональная цепочка работает только с объявленными переменными.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Пример использования опциональной цепочки:</span>

<span class="property">const</span> <span class="value">userJohn</span> = {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="value">surname:</span> <span class="string">"Smith"</span>,
  <span class="value">address:</span> {
    <span class="value">street:</span> <span class="string">"Fulton Street"</span>,
    <span class="value">building:</span> 11,
    <span class="value">apartment:</span> 22,
  },
};

<span class="property">const</span> <span class="value">userJulia</span> = {
  <span class="value">name:</span> <span class="string">"Julia"</span>,
  <span class="value">surname:</span> <span class="string">"Smith"</span>,
};

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">userJohn</span>.<span class="value">address</span>?.<span class="value">street</span>); <span class="comment">// Fulton Street, eсли указан адрес, то выдай мне улицу, если нет undefined</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">userJulia</span>.<span class="value">address</span>?.<span class="value">street</span>); <span class="comment">// undefined, тк Julia не ввела свой адрес</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Map</span>
      </p>
      <p class="text">
        Map - это коллекция ключ/значение, как и Object. Но основное отличие в
        том, что Map позволяет использовать ключи любого типа не приводя его к
        строке, в качестве ключа допускается использование других объектов.
      </p>
      <p class="text">
        Использование объекта в качестве ключа - является одной из главных
        особенностей Map.
      </p>
      <p class="text">
        Взаимодействовать с Map необходимо через его свойства и методы,
        отклонение от этого правила, превратит Map в обычный объект с его
        ограничениями в виде превращения ключей в строки.
      </p>
      <p class="text">Методы и свойства Map:</p>
      <ol class="list">
        <li class="item">
          <span class="highlight">new.Map()</span> - создаёт коллекцию
        </li>
        <li class="item">
          <span class="highlight">map.set(key, value)</span> - записывает по
          ключу key значение value.
        </li>
        <li class="item">
          <span class="highlight">map.get(key)</span> - возвращает значение по
          ключу или undefined, если ключ key отсутствует.
        </li>
        <li class="item">
          <span class="highlight">map.has(key)</span> - возвращает true, если
          ключ key присутствует в коллекции, иначе false.
        </li>
        <li class="item">
          <span class="highlight">map.delete(key)</span> - удаляет элемент
          (пару "ключ/значение") по ключу key.
        </li>
        <li class="item">
          <span class="highlight">map.clear()</span> - очищает коллекцию от
          всех элементов.
        </li>
        <li class="item">
          <span class="highlight">map.size</span> - возвращает текущее
          количество элементов.
        </li>
      </ol>
      <p class="text">Перебор Map:</p>
      <ol class="list">
        <li class="item">
          <span class="highlight">map.keys()</span> - возвращает итерируемый
          объект по ключам.
        </li>
        <li class="item">
          <span class="highlight">map.values()</span> - возвращает итерируемый
          объект по значениям.
        </li>
        <li class="item">
          <span class="highlight">map.entries()</span> - возвращает
          итерируемый объект по парам вида [ключ, значение], этот вариант
          используется по умолчанию в for of.
        </li>
      </ol>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Пример работы Map:</span>

<span class="property">const</span> <span class="value">map</span> = <span class="property">new</span> <span class="object">Map</span>();

<span class="value">map</span>.<span class="selector">set</span>(<span class="string">"1"</span>, <span class="string">"str 1"</span>); <span class="comment">// Строка в качестве ключа</span>
<span class="value">map</span>.<span class="selector">set</span>(1, <span class="string">"num 1"</span>); <span class="comment">// Цифра в качестве ключа</span>
<span class="value">map</span>.<span class="selector">set</span>(<span class="property">true</span>, <span class="string">"bool 1"</span>); <span class="comment">// Булево значение в качестве ключа</span>

<span class="comment">// Map сохраняет тип ключей, поэтому в нем это два разных значения:</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">map</span>.<span class="selector">get</span>(<span class="string">"1"</span>)); <span class="comment">// "str 1"</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">map</span>.<span class="selector">get</span>(1)); <span class="comment">// "num 1"</span>

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">map</span>.<span class="selector">size</span>); <span class="comment">// 3</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Использование объектов в качестве ключей</span>
<span class="comment">// В этом примере мы будем сохранять количество посещений для каждого пользователя</span>

<span class="property">const</span> <span class="value">john</span> = { <span class="value">name:</span> <span class="string">"John"</span> };
<span class="property">const</span> <span class="value">visitCountMap</span> = <span class="property">new</span> <span class="object">Map</span>();

<span class="value">visitCountMap</span>.<span class="selector">set</span>(<span class="value">john</span>, 123); <span class="comment">// Использовали объект в качестве ключа</span>

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">visitCountMap</span>.<span class="selector">get</span>(<span class="value">john</span>)); <span class="comment">// 123</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">visitCountMap</span>); <span class="comment">// Map(1) { { name: "John" } =&gt; 123 }</span>

<span class="comment">// Если бы мы вместо Map использовали объект {} то при записи ключа, он записался бы как "[object Object]"</span>

------------------------------------------------------------------------------------------------------------
<span class="console-chapter">Цепочка вызовов</span>
<span class="comment">// Каждый вызов map.set возвращает объект map, поэтому можем объединить вызовы в цепочку:</span>

<span class="value">map</span>.<span class="selector">set</span>(<span class="string">"1"</span>, <span class="string">"str 1"</span>)
   .<span class="selector">set</span>(1, <span class="string">"num 1"</span>)
   .<span class="selector">set</span>(<span class="property">true</span>, <span class="string">"bool 1"</span>);

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Перебор Map</span>
<span class="comment">// Для перебора коллекций Map используется 3 метода:</span>
<span class="comment">// map.keys() - возвращает итерируемый объект по ключам.</span>
<span class="comment">// map.values() - возвращает итерируемый объект по значениям.</span>
<span class="comment">// map.entries() - возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for of.</span>
<span class="comment">// Перебор в Map, в отличие от Object, происходит в том же порядке в каком происходило добавление элементов</span>

<span class="property">const</span> <span class="value">recipeMap</span> = <span class="property">new</span> <span class="object">Map</span>([
  [<span class="string">"Помидор"</span>, 500],
  [<span class="string">"Огурец"</span>, 250],
  [<span class="string">"Лук"</span>, 125],
]);

<span class="comment">// Перебор по ключам:</span>
<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">key</span> <span class="property">of</span> <span class="value">recipeMap</span>.<span class="selector">keys</span>()) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">key</span>); <span class="comment">// Помидор, Огурец, Лук</span>
}

<span class="comment">// Перебор по значениям:</span>
<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">value</span> <span class="property">of</span> <span class="value">recipeMap</span>.<span class="selector">values</span>()) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">value</span>); <span class="comment">// 500, 250, 125</span>
}

<span class="comment">// Перебор вида [ключ, значение]:</span>
<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">entry</span> <span class="property">of</span> <span class="value">recipeMap</span>) { <span class="comment">// Тоже самое что и recipeMap.entries()</span>
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">value</span>); <span class="comment">// Помидор, 500 и тд.</span>
}

------------------------------------------------------------------------------------------------------------
<span class="comment">// Map имеет встроенный метод forEach, позволяющий перебирать элементы</span>
<span class="comment">// Будем перебирать элементы из примера выше</span>

<span class="value">recipeMap</span>.<span class="selector">forEach</span>((<span class="value">value</span>, <span class="value">key</span>, <span class="value">map</span>) =&gt; {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">value</span>, <span class="value">key</span>, <span class="value">map</span>); <span class="comment">// 500 Помидор Map(3) { "Помидор" =&gt; 500, "Огурец" =&gt; 250, "Лук" =&gt; 125 } и тд.</span>
});

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Obect.entries(obj)</span>
<span class="comment">// Создает Map из Object. Получает объект и возвращает массив пар ключ-значение.</span>
<span class="comment">// Используется в том случае, когда нам необходимо сделать массив Map из Object.</span>

<span class="property">const</span> <span class="value">obj</span> = {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="value">age:</span> 30,
};

<span class="property">const</span> <span class="value">map</span> = <span class="property">new</span> <span class="object">Map</span>(<span class="object">Object</span>.<span class="selector">entries</span>(<span class="value">obj</span>));

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">map</span>.<span class="selector">get</span>(<span class="string">"name"</span>)); <span class="comment">// John</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">map</span>); <span class="comment">// Map(2) { "name" =&gt; "John", "age" =&gt; 20 }</span>

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Obect.fromEnties(map)</span>
<span class="comment">// Метод, который получив массив пар вида ключ-значение превращает его в Object.</span>

<span class="property">const</span> <span class="value">arr</span> = [
  [<span class="string">"Apples"</span>, 1],
  [<span class="string">"Oranges"</span>, 2],
  [<span class="string">"Bananas"</span>, 3],
];

<span class="property">const</span> <span class="value">obj</span> = <span class="object">Object</span>.<span class="selector">fromEntries</span>(<span class="value">arr</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">obj</span>); <span class="comment">// { Apples: 1, Oranges: 2, Bananas: 3 }</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Тоже самое можно делать и с Map, превращая его в объект:</span>

<span class="property">const</span> <span class="value">map</span> = <span class="property">new</span> <span class="object">Map</span>();

<span class="value">map</span>.<span class="selector">set</span>(<span class="string">"Apples"</span>, 1);
<span class="value">map</span>.<span class="selector">set</span>(<span class="string">"Oranges"</span>, 2);
<span class="value">map</span>.<span class="selector">set</span>(<span class="string">"Bananas"</span>, 3);

<span class="property">const</span> <span class="value">obj</span> = <span class="object">Object</span>.<span class="selector">fromEntries</span>(<span class="value">map</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">obj</span>); <span class="comment">// { Apples: 1, Oranges: 2, Bananas: 3 }</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Set</span>
      </p>
      <p class="text">
        Объект Set - это особый вид коллекции: "множество" значений (без
        ключей), где каждое значение может появляться только один раз.
      </p>
      <p class="text">
        Основная особенность Set в том, что при вызове set.add(value) с одним
        и тем же значением value, ничего не происходит, за счёт этого
        получается, что каждое значение появляется только один раз.
      </p>
      <p class="text">Методы и свойства Set:</p>
      <ol class="list">
        <li class="item">
          <span class="highlight">new Set(iterable)</span> - создаёт Set, и
          если в качестве аргумента был предоставлен итерируемый объект
          (обычно это массив), то копирует его значения в новый Set.
        </li>
        <li class="item">
          <span class="highlight">set.add(value)</span> - добавляет значение
          (если оно уже есть, то ничего не делает), возвращает тот же объект
          set.
        </li>
        <li class="item">
          <span class="highlight">set.delete(value)</span> - удаляет значение,
          возвращает true, если value было в множестве на момент вызова, иначе
          false.
        </li>
        <li class="item">
          <span class="highlight">set.has(value)</span> - возвращает true,
          если значение присутствует в множестве, иначе false.
        </li>
        <li class="item">
          <span class="highlight">set.clear()</span> - удаляет все имеющиеся
          значения.
        </li>
        <li class="item">
          <span class="highlight">set.size</span> - возвращает количество
          элементов в множестве.
        </li>
      </ol>
      <p class="text">
        Для перебора, Set имеет те же встроенные методы что и Map:
      </p>
      <ol class="list">
        <li class="item">
          <span class="highlight">set.keys()</span> - возвращает перебираемый
          объект для значений.
        </li>
        <li class="item">
          <span class="highlight">set.values()</span> - то же самое, что и
          set.keys(), присутствует для обратной совместимости с Map.
        </li>
        <li class="item">
          <span class="highlight">set.entries()</span> - возвращает
          перебираемый объект для пар вида [значение, значение], присутствует
          для обратной совместимости с Map.
        </li>
      </ol>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Пример работы Set:</span>
<span class="comment">// Мы ожидаем посетителей, и нам необходимо составить список. Повторные визиты не должны приводить к дубликатам.</span>

<span class="property">const</span> <span class="value">set</span> = <span class="property">new</span> <span class="object">Set</span>();

<span class="property">const</span> <span class="value">john</span> = {<span class="value">name:</span> <span class="string">"John"</span>};
<span class="property">const</span> <span class="value">pete</span> = {<span class="value">name:</span> <span class="string">"Pete"</span>};
<span class="property">const</span> <span class="value">mary</span> = {<span class="value">name:</span> <span class="string">"Mary"</span>};

<span class="value">set</span>.<span class="selector">add</span>(john);
<span class="value">set</span>.<span class="selector">add</span>(pete);
<span class="value">set</span>.<span class="selector">add</span>(mary);
<span class="comment">// Добавим тех кто уже есть в объекте:</span>
<span class="value">set</span>.<span class="selector">add</span>(john);
<span class="value">set</span>.<span class="selector">add</span>(pete);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">set</span>.<span class="value">size</span>); <span class="comment">// 3 - тех кого мы хотели добавить в конце, не добавились</span>

<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">prop</span> <span class="property">of</span> <span class="value">set</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">prop</span>.<span class="value">name</span>); <span class="comment">// John Pete Mary</span>
}

<span class="console-line">------------------------------------------------------------------------------------------------------------</span>
<span class="console-chapter">Перебор объекта Set:</span>
<span class="comment">// Мы можем перебрать объект set используя как for of, так и forEach.</span>

<span class="property">const</span> <span class="value">set</span> = <span class="property">new</span> <span class="object">Set</span>([<span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Banana"</span>]);

<span class="cycle-function">for</span> (<span class="property">const</span> <span class="value">prop</span> <span class="property">of</span> <span class="value">set</span>) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">prop</span>); <span class="comment">// Apple Orange Banana</span>
}

<span class="value">set</span>.<span class="selector">forEach</span>((<span class="value">item</span>, <span class="value">itemAgain</span>, <span class="value">set</span>) <span class="cycle-function">=&gt;</span> {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="value">item</span>, <span class="value">itemAgain</span>, <span class="value">set</span>); <span class="comment">// Apple Apple Set(3) { "Apple", "Orange", "Banana" } и тд</span>
});

<span class="comment">// Обратите внимание на одну особенность, функция forEach у Set имеет 3 аргумента, значение item, затем снова то же самое значение itemAgain и только потом целевой объект</span>
<span class="comment">// Это сделано для обратной совместимости с Map, для того чтобы можно было заменить Map на Set и наоборот.</span>
</code>
</pre>
      </div>
      <p class="text">
        <span class="text-offset">Деструктуризация объекта</span>
      </p>
      <p class="text">
        Ниже пример того, как объект можно деструктуризовать на переменные
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Синтаксис деструктурирующего присваивания для объекта:</span>
<span class="comment">// У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные.</span>
<span class="comment">// Левая сторона содержит "шаблон" для соответствующих свойств. Обычно это список названий переменных в {...}</span>
<span class="comment">// Так же в левой стороне мы можем указывать только те переменные, которые нам нужны и забирать их из объекта игнорируя остальные, не обязательно присваивать отдельные переменные всем свойствам</span>
<span class="property">const</span> { <span class="value">var1</span>, <span class="value">var2</span> } = { <span class="value">var1:</span> ..., <span class="value">var2:</span> ... }

<span class="comment">// Например:</span>
<span class="property">const</span> <span class="value">options</span> = {
  <span class="value">title:</span> <span class="string">"Menu"</span>,
  <span class="value">width:</span> 100,
  <span class="value">height:</span> 200  
};

<span class="comment">// Свойства options.title, options.width и options.height присваиваются соответствующим переменным</span>
<span class="property">const</span> {<span class="value">title</span>, <span class="value">width</span>, <span class="value">height</span>} = <span class="value">options</span>;

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">title</span>); <span class="comment">// Menu</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">width</span>); <span class="comment">// 100</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">height</span>); <span class="comment">// 200</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Не важен порядок присваивания, главное соблюдать именование</span>
<span class="property">const</span> {<span class="value">width</span>, <span class="value">title</span>, <span class="value">height</span>} = {<span class="value">title:</span> <span class="string">"Menu"</span>, <span class="value">height:</span> 200, <span class="value">width:</span> 100};

------------------------------------------------------------------------------------------------------------
<span class="comment">// Если же мы хотим дать переменной другое название, отличающееся от названия свойства, то мы должны использовать двоеточие</span>
<span class="property">const</span> {<span class="value">width</span>: <span class="value">w</span>, <span class="value">title</span>: <span class="value">t</span>, <span class="value">height</span>: <span class="value">h</span>} = <span class="value">options</span>;

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">t</span>); <span class="comment">// Menu</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">w</span>); <span class="comment">// 100</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">h</span>); <span class="comment">// 200</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Как и в случае с массивами, для свойств объекта можно устанавливать значения по умлчанию и использовать функции в присваивании:</span>
<span class="property">const</span> <span class="value">options</span> = {
  <span class="value">title:</span> <span class="string">"Menu"</span>
};

<span class="property">const</span> {<span class="value">width</span> = <span class="selector">prompt</span>(<span class="string">"Width?"</span>), <span class="value">height</span> = 200, <span class="value">title</span>} = <span class="value">options</span>;

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">width</span>); <span class="comment">// Результат ввода в prompt</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">height</span>); <span class="comment">// 200 - значение по умолчанию</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">title</span>); <span class="comment">// Присваивается одноименной переменной из массива справа</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Можно использовать переменную три точки ... - остаток объекта, для того, чтобы взять нужную переменную а остальное присвоить в отдельный объект</span>
<span class="property">const</span> <span class="value">options</span> = {
  <span class="value">title:</span> <span class="string">"Menu"</span>,
  <span class="value">width:</span> 100,
  <span class="value">height:</span> 200  
};

<span class="property">const</span> {<span class="value">title</span>, ...<span class="value">remainder</span>} = <span class="value">options</span>;

<span class="comment">// сейчас title = "Menu", remainder = {width: 100, height: 200}</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">remainder</span>.<span class="value">width</span>); <span class="comment">// 100</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">remainder</span>.<span class="value">height</span>); <span class="comment">// 200</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Присваивание при диструктуризации можно совершать напрямую со свойствами объекта:</span>
<span class="property">const</span> <span class="value">user</span> = {};

<span class="comment">// Метод split(" ") разбивает нашу строку на две части, обрезая ее по указанному в split символу, в нашем случае это пробел</span>
<span class="comment">// Мы получили две разделенные строки, далее они присваиваются как user.name = "John"; и user.surname = "Smith";</span>
[<span class="value">user</span>.<span class="value">name</span>, <span class="value">user</span>.<span class="value">surname</span>] = <span class="string">"John Smith"</span>.<span class="selector">split</span>(<span class="string">" "</span>);

<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>.<span class="value">name</span>); <span class="comment">// John</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">user</span>.<span class="value">surname</span>); <span class="comment">// Smith</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Мы можем использовать деструктуризацию для цикличного перебора свойств объекта:</span>
<span class="property">const</span> <span class="value">user</span> = {
  <span class="value">name:</span> <span class="string">"John"</span>,
  <span class="value">age:</span> 30,
};

<span class="cycle-function">for</span> (<span class="property">let</span> [<span class="value">key</span>, <span class="value">value</span>] <span class="property">of</span> <span class="object">Object</span>.<span class="selector">entries</span>(<span class="value">user</span>)) {
  <span class="value">console</span>.<span class="selector">log</span>(<span class="string">`</span><span class="property">${</span><span class="value">key</span><span class="property">}</span><span class="string">: </span><span class="property">${</span><span class="value">value</span><span class="property">}</span><span class="string">`</span>);
}
<span class="comment">// name: John
   age: 30</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Вложенная деструктуризация - если в объекте присутствует объект или массив со значениями, то нам необходимо скопировать его в точности соблюдая структуру</span>
<span class="property">const</span> <span class="value">options</span> = {
  <span class="value">size:</span> {
    <span class="value">width:</span> 100,
    <span class="value">height:</span> 200,
  },
  <span class="value">items:</span> [<span class="string">"Cake"</span>, <span class="string">"Donut"</span>],
  <span class="value">extra:</span> <span class="property">true</span>,
};

<span class="comment">// Для читаемости, деструктуризацию можно разбивать на несколько строк, но это не обязятельно</span>
<span class="property">const</span> {
  <span class="value">size:</span> {
    <span class="value">width</span>,
    <span class="value">height</span>,
  },
  <span class="value">items:</span> [<span class="value">item1</span>, <span class="value">item2</span>],
  <span class="value">title</span> = <span class="string">"Menu"</span>, <span class="comment">// Отстутствует в объекте (используется значение по умолчанию)</span>
} = <span class="value">options</span>;

<span class="comment">// Весь объект options, кроме свойства extra, которое в левой части отсутствует, присваивается в соответствующие переменные</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">title</span>); <span class="comment">// Menu</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">width</span>); <span class="comment">// 100</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">height</span>); <span class="comment">// 200</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">item1</span>); <span class="comment">// Cake</span>
<span class="value">console</span>.<span class="selector">log</span>(<span class="value">item2</span>); <span class="comment">// Donut</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Деструктуризацию можно так же использовать для функций с множеством параметров, передавая их как объект:</span>
<span class="property">const</span> <span class="value">options</span> = {
  <span class="value">title:</span> <span class="string">"My menu"</span>,
  <span class="value">items:</span> [<span class="string">"item1"</span>, <span class="string">"item2"</span>]  
};

<span class="comment">// Обратите внимание что параметры функции обёрнуты в {} для того чтобы они могли деструктурировать переданный в функцию объект</span>
<span class="comment">// Параметры так же могут принимать значения по умолчанию, функции и быть переименованы через двоеточие </span>
<span class="comment">// Для удобства разместим параметры на разных строчках</span>
<span class="cycle-function">function</span> <span class="selector">showMenu</span>({
  <span class="value">title</span> = <span class="string">"Untitled"</span>, <span class="comment">// Поменяется на "My menu"</span>
  <span class="value">width:</span> <span class="value">w</span> = 100, <span class="comment">// Применится значение по умолчанию, тк в переданном объекте нет свойства width</span>
  <span class="value">height:</span> <span class="value">h</span> = +<span class="selector">prompt</span>(<span class="string">"Height?"</span>), <span class="comment">// Результат ввода в prompt</span>
  <span class="value">items:</span> [<span class="value">i1</span>, <span class="value">i2</span>] <span class="comment">// Присвоятся соответствующие индексы массива const li1 = items[0]; и const li2 = items[1];</span>
}) {
  <span class="selector">alert</span>(<span class="string">`</span><span class="property">${</span><span class="value">title</span><span class="property">}</span><span class="string">: width:</span> <span class="property">${</span><span class="value">w</span><span class="property">}</span><span class="string">, height:</span> <span class="property">${</span><span class="value">h</span><span class="property">}</span><span class="string">`</span>); <span class="comment">// My menu: width: 100, height: 200</span>
  <span class="selector">alert</span>(<span class="string">`</span><span class="property">${</span><span class="value">i1</span><span class="property">}</span><span class="string">,</span> <span class="property">${</span><span class="value">i2</span><span class="property">}</span><span class="string">`</span>); <span class="comment">// item1, item2</span>
}

<span class="selector">showMenu</span>(<span class="value">options</span>);

<span class="comment">// Обратите внимание, что деструктурирование подразумевает, что в showMenu() будет обязательно передан аргумент</span>
<span class="comment">// Если нам нужно значение по умолчанию, то items: [] необходимо убрать из аргументов, либо назначить каждому элементу значение по умолчанию, тк для него нет свойств.</span>
<span class="comment">// Так же необходимо поменять : на = у items, потому что двоеточие подразумевает что мы ищем массив в свойстве, а свойства нет, что вызовет ошибку</span>

<span class="selector">showMenu</span>(); <span class="comment">// Такой вызов функции выдаст ошибку</span>
<span class="selector">showMenu</span>({}); <span class="comment">// Корректный вызов функции (при учете нюанаса с items, применит значения по умолчанию)</span>

------------------------------------------------------------------------------------------------------------
<span class="comment">// Чтобы не писать в вызове функции {}, мы можем приравнять весь наш объект с аргументами по умолчанию к {}</span>
<span class="comment">// Это работает как "если в функцию передали пустой аргумент, то возьми значения по умолчанию"</span>
<span class="comment">// Так же тут показано как можно исправить items из примера выше, те присвоить ему значения по умолчанию</span>
<span class="cycle-function">function</span> <span class="selector">showMenu</span>({
  <span class="value">title</span> = <span class="string">"Untitled"</span>,
  <span class="value">width:</span> <span class="value">w</span> = 100,
  <span class="value">height:</span> <span class="value">h</span> = +<span class="selector">prompt</span>(<span class="string">"Height?"</span>),
  <span class="value">items</span> = [<span class="value">i1</span> = <span class="string">"Some Item"</span>, <span class="value">i2</span> = <span class="string">"Some Item"</span>]
} = {}) {
  <span class="selector">alert</span>(<span class="string">`</span><span class="property">${</span><span class="value">title</span><span class="property">}</span><span class="string">: width:</span> <span class="property">${</span><span class="value">w</span><span class="property">}</span><span class="string">, height:</span> <span class="property">${</span><span class="value">h</span><span class="property">}</span><span class="string">`</span>); <span class="comment">// Untitled: width: 100, height: 200</span>
  <span class="selector">alert</span>(<span class="string">`</span><span class="property">${</span><span class="value">i1</span><span class="property">}</span><span class="string">,</span> <span class="property">${</span><span class="value">i2</span><span class="property">}</span><span class="string">`</span>); <span class="comment">// Some Item, Some Item</span>
  <span class="selector">alert</span>(<span class="value">items</span>); <span class="comment">// [i1 = "Some Item", i2 = "Some Item"]</span>
}

<span class="selector">showMenu</span>(); <span class="comment">// Теперь такой код не вызывает ошибку, благодаря приравниванию объекта с аргументами функции к {}</span>
</code>
</pre>
      </div>
    </div>
    <!-- Block 06 end -->
    <!-- Block 1 start -->
    <div class="b1 block">
      <p class="title"><span class="title-number">1.</span> DOM Elemets</p>
      <p class="text">
        <span class="text-offset">Взаимодействие с DOM деревом</span> - это
        взаимодействие с HTML тегами при помощи JavaScript.
      </p>
      <p class="text">
        Для того чтобы при помощи JavaScript взаимодействовать с тегами, их
        необходимо сначала найти. Для этого нам понадобится метод
        <span class="highlight">document<wbr />.querySelector<wbr />(".<wbr />class-name");</span>, внутрь скобок этого
        метода мы передаем необходимый селектор,
        обязательно в кавычках и с точкой в начале.
      </p>
      <p class="text">
        <span class="highlight">document</span> - это объект, который хранит
        методы для работы со страницей. Это некая точка входа для получения
        содержимого страницы. Кроме
        <span class="highlight">querySelector()</span> существует еще
        множество других методов.
      </p>
      <p class="text">
        Несколько важных моментов, если мы взаимодейсвтуем с HTML элементами,
        то JS должен быть подключен после того, как прогрузился HTML, если JS
        файл один, то он подключается перед закрывающим тегом body, если же
        для каждого блока у вас отдельный JS файл, то он подключается как в
        примере ниже. Еще стоит упомянуть, что метод
        <span class="highlight">document<wbr />.querySelector();</span> умеет
        находить только один элемент с нужным селектором, к примеру если у вас
        много элеменов с одинаковыми классами, то этот метод найдет вам только
        самый первый из них.
      </p>
      <div class="code-example">
        <p class="text">
          В данном примере мы создаем переменную
          <span class="text-bg"><span class="property">let</span>
            <span class="value">text</span></span>, и присваиваем ей метод
          <span class="text-bg">document<wbr />.querySelector<wbr />(<span class="string">".b1__text"</span>);</span>.
          Таким образом мы находим селектор
          <span class="string text-bg">.b1__text</span> в HTML файле.
        </p>
        <p class="text">
          Далее, обращаясь к уже созданной переменной, при помощи свойства
          <span class="text-bg">style</span>, которое позволяет найти или
          изменить свойства элемента записав их инлайново в HTML, меняем цвет
          текста на красный
          <span class="text-bg"><span class="property">let</span>
            <span class="value">text</span> = document<wbr />.querySelector<wbr />(<span
              class="string">".b1__text"</span>)<wbr />.style<wbr />.color=<wbr /><span
              class="string">"red"</span>;</span>. В данном примере мы написали свойство style и задали ему
          параметры color=<wbr />"red", что перекрасило наш текст после
            загрузки страницы в красный. Стоит отметить, что использовать JS для
            изменения стилей таким образом как в примерах ниже, не совсем
            корректно, тк они указываются инлайново, что противоречит БЭМу и в
            будущем будет мешать нам перебить эти стили.
        </p>
        <div class="code-realisation">
          <p class="b1__text">
            Далеко-далеко за словесными горами в стране гласных и согласных
            живут рыбные тексты.
          </p>
          <script src="js/b1.js"></script>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">p class=</span><span class="string">"b1__text"</span>&gt;
  Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты.
&lt;/<span class="tag-property">p</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"js/b1.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="tag-property">let</span> <span class="value">text</span> = document.querySelector(<span class="string">".b1__text"</span>);

<span class="value">text</span>.style.color = <span class="string">"red"</span>;
</code>
</pre>
        </div>
      </div>
      <p class="text">
        Для того чтобы обойти ограничение предыдущего метода и применять стили
        к нескольким одинаковым селекторам, нам понадобится метод который ищет
        массив (набор элементов) -
        <span class="highlight">document.<wbr />querySelectorAll<wbr />(".class-name")</span>, а так же <span
          class="highlight">forEach</span> - метод массива
        который по очереди проходит по элементам этого массива и
        <span class="highlight">function<wbr />(name) <wbr />{...}</span> -
        функция в которую мы будем записывать условия.
      </p>
      <div class="code-example">
        <p class="text">
          В данном примере мы создаем метод
          <span class="text-bg">document.<wbr />querySelectorAll<wbr />(<span
              class="string">".b1__text-two"</span>);</span>, который позволяет нам найти массив селекторов
          <span class="string text-bg">.b1__text-two</span> в HTML файле.
        </p>
        <p class="text">
          Добавляем к этому массиву <span class="text-bg">forEach</span> и
          создаем в нем функцию которую можно назвать как угодно, в нашем
          примере назовем ее
          <span class="text-bg cycle-function">element</span> и внутри этой
          функции, в фигурных скобках обращаясь к созданной функции пропишем
          <span class="text-bg"><span class="cycle-function">element</span>.style<wbr />.color =
              "red";</span>, пример в коде ниже.
        </p>
        <div class="code-realisation">
          <p class="b1__text-two">
            Далеко-далеко за словесными горами в стране гласных и согласных
            живут рыбные тексты.
          </p>
          <p class="b1__text-two">
            Далеко-далеко за словесными горами в стране гласных и согласных
            живут рыбные тексты.
          </p>
          <p class="b1__text-two">
            Далеко-далеко за словесными горами в стране гласных и согласных
            живут рыбные тексты.
          </p>
          <script src="js/b1__two.js"></script>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">p class=</span><span class="string">"b1__text-two"</span>&gt;
  Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты.
&lt;/<span class="tag-property">p</span>&gt;
&lt;<span class="tag-property">p class=</span><span class="string">"b1__text-two"</span>&gt;
  Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты.
&lt;/<span class="tag-property">p</span>&gt;
&lt;<span class="tag-property">p class=</span><span class="string">"b1__text-two"</span>&gt;
  Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты.
&lt;/<span class="tag-property">p</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"js/b1__two.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-js">JS</span>

document.querySelectorAll(<span class="string">".b1__text-two"</span>).forEach(<span class="cycle-function">function</span>(<span class="cycle-function">element</span>) {
  <span class="cycle-function">element</span>.style.color = "red";
});
</code>
</pre>
        </div>
      </div>
      <p class="text">
        Для того чтобы добавлять классы в HTML разметку, нам необходимо найти
        нужный селектор при помощи
        <span class="highlight">document.<wbr />querySelector<wbr />(".class-name")</span>, а затем, при помощи метода
        <span class="highlight">block.<wbr />classList.<wbr />add<wbr />("add-class-name");</span>, добавить необходимый
        класс в HTML разметку.
      </p>
      <div class="code-example">
        <p class="text">
          В данном примере нам необходимо сдвинуть блок на 100px вправо при
          помощи transform: translate и JS. Для этого мы создаем класс
          <span class="text-bg selector">.b1__translate-three</span> и наша
          задача будет добавить этот класс в HTML разметку, чтобы применились
          нужные стили.
        </p>
        <p class="text">
          В JavaScript файле создаем переменную
          <span class="text-bg"><span class="property">let</span>
            <span class="value">block</span></span>, при помощи
          <span class="text-bg">document.<wbr />querySelector<wbr />(<span
              class="string">".b1__block-three"</span>);</span>
          находим нужный селектор в HTML файле -
          <span class="text-bg string">"b1__block-three"</span>
        </p>
        <p class="text">
          Далее обращаемся к созданной переменной и применяем новый метод
          <span class="text-bg">classList</span> и у этого метода есть еще
          один <span class="text-bg">add("")</span> позволяет что либо
          добавить, в скобки указываем то что мы хотим добавить, в нашем
          случае это будет созданный нами класс
          <span class="text-bg">block.<wbr />classList.<wbr />add<wbr />(<span
              class="string">"b1__translate-three"</span>);</span>, обратите внимание что в этом методе мы не используем
          точку
          вначале селектора, тк мы добавляем класс. Есть и обратный метод,
          который называется
          <span class="text-bg">classList.<wbr />remove<wbr />("class.name")</span>. Данные действия позволили нам
          добавить стиль в HTML файл, к
          нужному нам селектору.
        </p>
        <div class="code-realisation">
          <div class="b1__block-three"></div>
          <script src="js/b1__three.js"></script>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">div class=</span><span class="string">"b1__block-three"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"js/b1__three.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

.<span class="selector">b1__block-three</span> {
  <span class="tag-property">width</span>: 200px;
  <span class="tag-property">height</span>: 200px;
  <span class="tag-property">background-color</span>: crimson;
}

.<span class="selector">b1__translate-three</span> {
  <span class="tag-property">transform</span>: translateY(-46px);
}
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="property">let</span> <span class="value">block</span> = document.querySelector(<span class="string">".b1__block-three"</span>);

<span class="value">block</span>.classList.add(<span class="string">"b1__translate-three"</span>);
</code>
</pre>
        </div>
      </div>
    </div>
    <!-- Block 1 end -->
    <!-- Block 2 start -->
    <div class="b2 block">
      <p class="title"><span class="title-number">2.</span> События</p>
      <p class="text">
        <span class="text-offset">События в JS</span> - это то что происходит
        со страницей после какого-либо действия, например вы нажали на кнопку
        и появился баннер. Обработкой событий в JavaScript занимается метод
        <span class="highlight">addEventListener</span> - дословно добавить
        обработчик события.
      </p>
      <div class="code-example">
        <p class="text">
          В данном примере мы будем отслеживать нажатие на блок и после
          нажатия будем смещать этот блок вправо на 100px. Для начала мы
          создаем переменную
          <span class="text-bg"><span class="tag-property">let</span>
            <span class="value">b2__block</span></span>
          и присваиваем ей метод
          <span class="text-bg">document.<wbr />querySelector<wbr />(<span class="string">".b2__block"</span>);</span>,
          находим элемент с классом
          <span class="text-bg string">.b2__block</span>.
        </p>
        <p class="text">
          После этого мы присваиваем созданной переменной обработчик собитий и
          в скобочках указываем встроенную функцию, в нашем случае мы хотим
          отслеживать клик
          <span class="text-bg"><span class="selector">addEventListener</span><wbr />(<span
              class="string">"click"</span>);</span>, далее, мы должны указать что будет происходить после того как мы
          отследили клик, для этого, через запятую создается функция
          <span class="text-bg"><span class="selector">addEventListener</span><wbr />(<span
              class="string">"click"</span>, <span class="cycle-function">function</span>()
            <wbr />{...});</span>
          которая что-то сделает, обратите внимание что в данном случае этой
          функции не обязательно давать имя, тк она активируется сразу после
          того как мы отследили клик и от этой функции нам нужно только
          действие.
        </p>
        <p class="text">
          В фигурных скобках мы указываем метод переключатель
          <span class="text-bg"><span class="value">block__2</span>.classList<wbr />.<wbr />toggle<wbr />(<span
              class="string">"b2__translate"</span>);</span>. Метод <span class="text-bg">toggle</span> - переключатель,
          можно
          заменить на две функции <span class="text-bg">add</span> - добавить
          и <span class="text-bg">remove</span> - удалить, но проще указать
          один <span class="text-bg">toggle</span>.
        </p>
        <div class="code-realisation">
          <div class="b2__block"></div>
          <script src="js/b2.js"></script>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">div class=</span><span class="string">"b2__block"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"js/b2.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

.<span class="selector">b2__block</span> {
  <span class="tag-property">width</span>: 200px;
  <span class="tag-property">height</span>: 200px;
  <span class="tag-property">background-color</span>: crimson;
}

.<span class="selector">b2__translate</span> {
  <span class="tag-property">transform</span>: translateX(100px);
}
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="property">let</span> <span class="value">b2__block</span> = document.querySelector(<span class="string">".b2__block"</span>);

<span class="value">b2__block</span>.<span class="selector">addEventListener</span>(<span class="string">"click"</span>, <span class="cycle-function">function</span>() {
  <span class="value">b2__block</span>.classList.toggle(<span class="string">"b2__translate"</span>);
});
</code>
</pre>
        </div>
      </div>
      <div class="code-example">
        <p class="text">
          В данном примере будет реализация кнопки "Показать еще", которая
          используется во множестве интернет магазинов с товарами, когда
          товары не помещаются на один экран. Для этого мы создадим 4 карточки
          товара и скроем 2 из них, подставим кнопку, по нажатию на нее, 2
          оставшихся блока должны появиться а кнопка исчезнуть.
        </p>
        <p class="text">
          Что происходит в HTML и CSS? Сначала создаются 4 блока, затем 2 из
          них скрываются при помощи CSS стиля:
          <span class="text-bg">.<span class="selector">b2__two-block<wbr />:nth-child<wbr />(n + 3)</span>
            {<span class="tag-property">display</span>: none;}</span>, добавляются 2 класса с которыми будет
          взаимодействовать JS,
          которые делают блоки видимыми:
          <span class="text-bg">.<span class="selector">b2__two-block<wbr />.b2__two-block--visible</span>
            {<span class="tag-property">display</span>: block;}</span>
          (удлиннение селектора в данном случае необходимо для того чтобы
          перебить вес предыдущего), а кнопку невидимой:
          <span class="text-bg">.<span class="selector">b2__two-button-wrapper--hidden</span>
            {<span class="tag-property">display</span>: none;}</span>.
        </p>
        <p class="text">
          В JS мы создаем две переменные
          <span class="text-bg"><span class="value">b2__twoButton</span></span>
          и
          <span class="text-bg"><span class="value">b2__twoBlock</span></span>, добавляем обработчик событий на
          <span class="text-bg"><span class="value">b2__twoButton</span></span>
          и по клику проходимся по всем элементам
          <span class="text-bg"><span class="value">b2__twoBlock</span></span>
          и делаем их видимыми, а так же у нас появляется новый метод
          <span class="text-bg">closest</span> - близкий, позволяет обратиться
          к родителю элемента, используя этот метод мы обращаемся к родителю
          нашей кнопки и скрываем весь блок целиком.
        </p>
        <div class="code-realisation">
          <div class="b2__two-block-wrapper">
            <div class="b2__two-block"></div>
            <div class="b2__two-block"></div>
            <div class="b2__two-block"></div>
            <div class="b2__two-block"></div>
          </div>
          <div class="b2__two-button-wrapper">
            <button class="b2__two-button">Показать ещё</button>
          </div>
          <script src="js/b2__two.js"></script>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">div class=</span><span class="string">"b2__two-block-wrapper"</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b2__two-block"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b2__two-block"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b2__two-block"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b2__two-block"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b2__two-block"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
&lt;/<span class="tag-property">div</span>&gt;
&lt;<span class="tag-property">div class=</span><span class="string">"b2__two-button-wrapper"</span>&gt;
  &lt;<span class="tag-property">button class=</span><span class="string">"b2__two-button"</span>&gt;
    Показать ещё
  &lt;/<span class="tag-property">button</span>&gt;
&lt;/<span class="tag-property">div</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"js/b2__two.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

.<span class="selector">b2__two-block-wrapper</span> {
  <span class="tag-property">width</span>: 100%;
  <span class="tag-property">height</span>: 200px;
  <span class="tag-property">background-color</span>: crimson;
}

.<span class="selector">b2__two-block</span> {
  <span class="tag-property">width</span>: 100%;
  <span class="tag-property">max-width</span>: 200px;
  <span class="tag-property">min-height</span>: 100px;
  <span class="tag-property">outline</span>: 1px solid tomato;
  <span class="tag-property">border-radius</span>: 10px;
}

.<span class="selector">b2__two-block:nth-child(n + 3)</span> {
  <span class="tag-property">display</span>: none;
}

.<span class="selector">b2__two-block:not(:last-child)</span> {
  <span class="tag-property">margin-bottom</span>: 5px;
}

.<span class="selector">b2__two-button-wrapper</span> {
  <span class="tag-property">display</span>: flex;
  <span class="tag-property">justify-content</span>: center;
}

.<span class="selector">b2__two-button</span> {
  <span class="tag-property">padding</span>: 10px 12px;
  <span class="tag-property">background-color</span>: var(--gray);
  <span class="tag-property">border-radius</span>: 10px;
}

.<span class="selector">b2__two-block.b2__two-block--visible</span> {
  <span class="tag-property">display</span>: block;
}

.<span class="selector">b2__two-button-wrapper--hidden</span> {
  <span class="tag-property">display</span>: none;
}
</code>
</pre>
        </div>
        <div class="console">
          <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="property">const</span> <span class="value">b2__twoButton</span> = document.querySelector(<span class="string">".b2__two-button"</span>);
<span class="property">const</span> <span class="value">b2__twoBlock</span> = document.querySelector(<span class="string">".b2__two-block"</span>);

<span class="value">b2__twoButton</span>.<span class="selector">addEventListener</span>(<span class="string">"click"</span>, <span class="cycle-function">() =&gt;</span> {
  <span class="value">b2__twoBlock</span>.forEach(elements <span class="cycle-function">() =&gt;</span> {
    elements.classList.add(<span class="string">"b2__two-block--visible"</span>);
    <span class="value">b2__twoButton</span>.closest(<span class="string">".b2__two-button-wrapper"</span>).classList.add(<span class="string">"b2__two-button-wrapper--hidden"</span>);
  });
});
</code>
</pre>
        </div>
      </div>
    </div>
    <!-- block 2 end -->
    <!-- block 3 start -->
    <div class="b3 block">
      <p class="title"><span class="title-number">3.</span> Табы</p>
      <p class="text">
        <span class="text-offset">Таб</span> - это кнопка, которая отвечает за
        показ определенного контента по нажатию на нее, представим что у нас в
        хэдере есть несколько кнопок с разными разделами сайта и по их нажатию
        у нас меняется картинка в блоке ниже.
      </p>
      <p class="text">
        Чтобы сделать табы на сайте, мы напишем собственный JavaScript-код,
        который будет показывать/скрывать нужные нам блоки по клику.
      </p>
      <p class="text">
        Для начала размечаем HTML, тут у кнопок мы видим дата-атрибуты - они
        применяются когда необходимо связать разные элементы между собой. Дата
        атрибут записывается в открывающий тег таким образом:
        <span class="text-bg">&lt;<span class="tag-property">button class</span>=<span class="string">"b3__tabs-nav-btn
            b3__tabs-nav-btn--active"</span>
          <span class="tag-property">data-path</span>=<span class="string">"one"</span>&gt;</span>, вместо path можно
        написать все что угодно, а в значении задана
        нумерация от одного до трех. У блоков с классом
        <span class="text-bg string">tabs-item</span> также есть дата-атрибут
        - <span class="text-bg tag-property">data-target</span>, со значениями
        схожими с дата-атрибутами кнопок (нумерация от одного до трех). Так же
        у первой кнопки и блока заданы дополнительные классы с префиксом
        <span class="text-bg string">--active</span>, для того чтобы особым
        образом стилизовать эти элементы, они будут начальными / активными при
        первом заходе на страницу. Таким образом мы связали кнопки и блоки
        <span class="text-bg">&lt;<span class="tag-property">div</span>&gt;</span>
        и дальнейшая логика будет заключаться в переключении контента в блоках
        при помощи кнопок.
      </p>
      <p class="text">
        Далее мы скрываем элементы которые не должны показываться:
        <span class="text-bg"><span class="selector">.b3__tabs-item</span> {<span class="tag-property">display</span>:
          none;}</span>, а элементы с префиксом --active делаем активными:
        <span class="text-bg"><span class="selector">.b3__tabs-item--active</span> {<span
            class="tag-property">display</span>: block;}</span>
      </p>
      <ul class="list">
        <li class="item">
          <span class="text-offset">Краткое разъяснение работы скрипта:</span>
        </li>
        <li class="item">
          - На кнопку навешивается цикл и создается функция
          <span class="text-bg value">element</span>
        </li>
        <li class="item">
          - Далее на <span class="text-bg value">element</span> навешивается
          обработчик событий и создается функция
          <span class="text-bg value">e</span> и по клику отслеживается вся
          информация о кнопке, включая значение
          <span class="text-bg tag-property">path</span> в HTML разметке. Вся
          информация записывается в константу с именем
          <span class="text-bg value">path</span>
        </li>
        <li class="item">
          - У всех кнопок удаляется класс с префиксом --active
        </li>
        <li class="item">
          - Далее кнопке на которой клик и функция
          <span class="text-bg value">e</span> с таргетом, присваивается класс
          с префиксом --active, для того чтобы сделать активной именно ту
          кнопку на которою мы нажали
        </li>
        <li class="item">
          - У всех контентных элементов удаляется класс с префиксом --active
        </li>
        <li class="item">
          - Последняя строчка проходится по всему документу и ищет в теагах
          <span class="text-bg string">`[data-target=<wbr />"<span class="property">${</span><span
              class="value">path</span><span class="property">}</span>"]`</span>
          - data-target = наша кликнутая кнопка, как только находит,
          присваивает ему класс с префиксом --active
        </li>
      </ul>
      <p class="text">
        Скрипт ищет все кнопки и все элементы табов в переменных. Мы создаем
        две переменные <span class="text-bg value">b3__tabsBtn</span> и
        <span class="text-bg value">b3__tabsItem</span> с методом
        <span class="text-bg">querySelectorAll</span>, одна ищет все кнопки,
        другая все блоки. Начинаем программу с того, что вешаем на
        <span class="text-bg value">b3__tabsBtn</span> цикл
        <span class="text-bg">forEach</span> с функцией
        <span class="text-bg value">element</span>, на функцию вешаем
        обработчик событий с функцией <span class="text-bg value">e</span>, в
        ней создаем константу, которая будет записывать в себя всю информацио
        о нажатой кнопке, включая значение атрибута path:
        <span class="text-bg"><span class="property">const</span>
          <span class="value">path</span> = e.<wbr />currentTarget<wbr />.dataset<wbr />.path;</span>
        Следующим шагом у всех кнопок мы удаляем класс с префиксом --active, и
        добавляем его той кнопке, на которой клик и функция
        <span class="text-bg value">e</span>, для того чтобы сделать активной
        именно ту кнопку на которою мы нажали. У всех контентных элементов
        удаляем класс с префиксом --active, и присваиваем его при помощи
        <span class="text-bg">document.<wbr />querySelector<wbr />(<span class="string">`[data-target=<wbr />"<span
              class="property">${</span><span class="value">path</span><span
              class="property">}</span>"]`</span>).classList.<wbr />add<wbr />(<span
            class="string">"b3__tabs-item--active"</span>);</span>, эта строчка проходится по всему документу и ищет в
        теагах запись
        <span class="text-bg string">`[data-target=<wbr />"<span class="property">${</span><span
            class="value">path</span><span class="property">}</span>"]`</span>
        (напомню, что нужный path лежит в переменной
        <span class="text-bg"><span class="property">const</span>
          <span class="value">path</span></span>
        - та переменная которая получила всю информацию о кнопке на которую мы
        кликнули), как только
        <span class="text-bg"><span class="property">${</span><span class="value">path</span><span
            class="property">}</span></span>
        совпал, скрипт присваивает элементу класс с префиксом --acrive, наш
        элемент активен!
      </p>
      <div class="code-realisation">
        <ul class="b3__tabs-nav">
          <li class="b3__tabs-nav-item">
            <button class="b3__tabs-nav-btn b3__tabs-nav-btn--active" data-path="one">
              Первый таб
            </button>
          </li>
          <li class="b3__tabs-nav-item">
            <button class="b3__tabs-nav-btn" data-path="two">
              Второй таб
            </button>
          </li>
          <li class="b3__tabs-nav-item">
            <button class="b3__tabs-nav-btn" data-path="three">
              Третий таб
            </button>
          </li>
        </ul>
        <div class="b3__tabs-content">
          <div class="b3__tabs-item b3__tabs-item--active" data-target="one">
            Tab 1
          </div>
          <div class="b3__tabs-item" data-target="two">Tab 2</div>
          <div class="b3__tabs-item" data-target="three">Tab 3</div>
        </div>
        <script src="js/b3.js"></script>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">ul class=</span><span class="string">"b3__tabs-nav"</span>&gt;
  &lt;<span class="tag-property">li class=</span><span class="string">"b3__tabs-nav-item"</span>&gt;
    &lt;<span class="tag-property">button class=</span><span class="string">"b3__tabs-nav-btn b3__tabs-nav-btn--active"</span> <span class="tag-property">data-path=</span><span class="string">"one"</span>&gt;
      Первый таб
    &lt;/<span class="tag-property">button</span>&gt;
  &lt;/<span class="tag-property">li</span>&gt;
  &lt;<span class="tag-property">li class=</span><span class="string">"b3__tabs-nav-item"</span>&gt;
    &lt;<span class="tag-property">button class=</span><span class="string">"b3__tabs-nav-btn"</span> <span class="tag-property">data-path=</span><span class="string">"two"</span>&gt;
      Второй таб
    &lt;/<span class="tag-property">button</span>&gt;
  &lt;/<span class="tag-property">li</span>&gt;
  &lt;<span class="tag-property">li class=</span><span class="string">"b3__tabs-nav-item"</span>&gt;
    &lt;<span class="tag-property">button class=</span><span class="string">"b3__tabs-nav-btn"</span> <span class="tag-property">data-path=</span><span class="string">"three"</span>&gt;
      Третий таб
    &lt;/<span class="tag-property">button</span>&gt;
  &lt;/<span class="tag-property">li</span>&gt;
&lt;/<span class="tag-property">ul</span>&gt;
&lt;<span class="tag-property">div class=</span><span class="string">"b3__tabs-content"</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b3__tabs-item b3__tabs-item--active"</span> <span class="tag-property">data-target=</span><span class="string">"one"</span>&gt;
    Tab 1
  &lt;/<span class="tag-property">div</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b3__tabs-item"</span> <span class="tag-property">data-target=</span><span class="string">"two"</span>&gt;
    Tab 2
  &lt;/<span class="tag-property">div</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b3__tabs-item"</span> <span class="tag-property">data-target=</span><span class="string">"three"</span>&gt;
    Tab 3
  &lt;/<span class="tag-property">div</span>&gt;
&lt;/<span class="tag-property">div</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"js/b3.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

<span class="selector">.b3__tabs-nav-btn--active</span> {
  <span class="tag-property">color</span>: tan;
}

<span class="selector">.b3__tabs-item</span> {
  <span class="tag-property">display</span>: none;
}

<span class="selector">.b3__tabs-item--active</span> {
  <span class="tag-property">display</span>: block;
}
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="property">let</span> <span class="value">b3__tabsBtn</span> = document.querySelectorAll(<span class="string">".b3__tabs-nav-btn"</span>);
<span class="property">let</span> <span class="value">b3__tabsItem</span> = document.querySelectorAll(<span class="string">".b3__tabs-item"</span>);

<span class="value">b3__tabsBtn</span>.forEach(<span class="value">element</span> <span class="cycle-function">=&gt;</span> {
  <span class="value">element</span>.<span class="selector">addEventListener</span>(<span class="string">"click"</span>, <span class="value">e</span> <span class="cycle-function">=&gt;</span> {
    <span class="property">const</span> <span class="value">path</span> = <span class="value">e</span>.currentTarget.dataset.path;

    <span class="value">b3__tabsBtn</span>.forEach(<span class="value">btn</span> <span class="cycle-function">=&gt;</span> {
      <span class="value">btn</span>.classList.remove(<span class="string">"b3__tabs-nav-btn--active"</span>);
    });

    <span class="value">e</span>.currentTarget.classList.add(<span class="string">"b3__tabs-nav-btn--active"</span>);

    <span class="value">b3__tabsItem</span>.forEach(<span class="value">element</span> <span class="cycle-function">=&gt;</span> {
      <span class="value">element</span>.classList.remove(<span class="string">"b3__tabs-item--active"</span>);
    });

    document.querySelector(<span class="string">`[data-target="<span class="property">${</span><span class="value">path</span><span class="property">}</span>"]`</span>).classList.add(<span class="string">"b3__tabs-item--active"</span>);
  });
});
</code>
</pre>
      </div>
    </div>
    <!-- Block 3 end -->
    <!-- Block 4 start -->
    <div class="b4 block">
      <p class="title">
        <span class="title-number">4.</span> Слайдер и его готовые решения
      </p>
      <p class="text">
        <span class="text-offset">Слайдер</span> - это UI элемент,
        представляющий из себя фотографии и две кнопки для пролистывания этих
        фотографий по нажатию на кнопки. В данном примере мы будем
        взаимодействовать с готовой библиотекой под названием
        <a class="link" href="https://swiperjs.com/" target="_blank">Swiper</a>.
      </p>
      <p class="text">
        Давайте приступим к ее установке! Для того чтобы установить какую-либо
        библиотеку к себе, мы в первую очередь смотрим на ее популярность на
        гитхабе. Переходим на сайт и ищем кнопку get started, у любой хорошей
        библиотеки должна быть инструкция по ее использованию и установке, в
        нашем случае мы пойдем по пути через прямое подключение JS и стилей
        через ссылку CDN.
      </p>
      <ul class="list">
        <li class="item">
          <span class="text-offset">Как пользоваться библиотекой Swiper?</span>
        </li>
        <li class="item">- Подключаем ссылку со стилями в хедере сайта</li>
        <li class="item">- Подключаем JS</li>
        <li class="item">- В HTML размечаем свайпер по примеру на сайте</li>
        <li class="item">
          - Инициализируем свайпер, на сайте есть пример, его нужно
          скопировать, создать JS файл, вставить его туда и подключить его к
          сайту
        </li>
        <li class="item">
          - Классу <span class="text-bg string">swiper</span> необходимо
          задать ширину
        </li>
        <li class="item">
          - На сайте во вкладке API &gt; Parameters расположены все параметры
          для настройки слайдера, выборочно мы берем то что нам нужно и
          вписываем все в наш JS файл, можно удалить все что было после
          инициализации кроме первой строчки
        </li>
        <li class="item">
          - Настроек огромное множество и все можно делать под себя, через
          DevTools вы можете посмотреть какие настройки были применены к этому
          слайдеру
        </li>
      </ul>
      <div class="code-realisation">
        <div class="swiper">
          <div class="swiper-wrapper">
            <div class="swiper-slide">
              <img class="b4__img" src="assets/img/b4__1.jpg" alt="Котенок" />
            </div>
            <div class="swiper-slide">
              <img class="b4__img" src="assets/img/b4__2.jpg" alt="Котенок" />
            </div>
            <div class="swiper-slide">
              <img class="b4__img" src="assets/img/b4__3.jpg" alt="Котенок" />
            </div>
            <div class="swiper-slide">
              <img class="b4__img" src="assets/img/b4__4.jpg" alt="Котенок" />
            </div>
            <div class="swiper-slide">
              <img class="b4__img" src="assets/img/b4__5.jpg" alt="Котенок" />
            </div>
            <div class="swiper-slide">
              <img class="b4__img" src="assets/img/b4__6.jpg" alt="Котенок" />
            </div>
          </div>
          <div class="swiper-button-prev"></div>
          <div class="swiper-button-next"></div>
          <div class="swiper-pagination"></div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/swiper@8/swiper-bundle.min.js"></script>
        <script src="js/b4.js"></script>
      </div>
    </div>
    <!-- Block 4 end -->
    <!-- Block 5 start -->
    <div class="b5 block">
      <p class="title">
        <span class="title-number">5.</span> Аккордеон и его готовые решения
      </p>
      <p class="text">
        <span class="text-offset">Аккордеон</span> - это UI элемент,
        представляющий из себя заголовок, нажатие на который раскрывает
        контент находящийся в нем, такой элемент веб-дизайна еще иногда
        называют спойлером. В данном примере мы будем взаимодействовать с
        готовой библиотекой под названием
        <a class="link" href="https://jqueryui.com/accordion/" target="_blank">jQuery-accordion</a>.
      </p>
      <p class="text">
        Устанавливать библиотеку мы будем через CDN, другими словами, будем
        вставлять ссылки на ресурсы.
      </p>
      <ul class="list">
        <li class="item">
          <span class="text-offset">Как пользоваться библиотекой jQuery-accordion?</span>
        </li>
        <li class="item">
          - Размечаем HTML - аккордеон представляет из себя список с классом
          <span class="text-bg string">accordion</span> (он нам понадобится
          для инициализации, включения, плагина), в котром находятся элементы
          списка
          <span class="text-bg">&lt;<span class="tag-property">li</span>&gt;</span>
          а в них заголовок и параграф с текстом
        </li>
        <li class="item">
          - Подключаем файл со стилями по инструкции представленной на сайте,
          в ссылке выше. Подключать необходимо раньше вашего файла со стилями,
          чтобы всегда была возможность перебить стандартные стили плагина.
        </li>
        <li class="item">
          - Подключаем два JS скрипта через CDN в конец страницы / нашего
          примера, первый скрипт отвечает за подключение библиотеки jQuery, а
          второй за библиотеку с аккордеоном.
        </li>
        <li class="item">
          - Третим, сымым последним, подключаем наш JS скрипт в котром мы
          будем инициализировать (подключать) наш аккордеон, чтобы подключить
          его достаточно прописать:
          <span class="text-bg">$(<span class="string">".accordion"</span>)<wbr />.accordion();</span>. В этом коде мы
          обратились к элементу с классом
          <span class="text-bg string">".accordion"</span> и инициализировали
          метод <span class="text-bg">accordion()</span>
        </li>
        <li class="item">
          - Далее мы можем стилизовать аккордеон при помощи созданного нами JS
          скрипта с инициализованным плагином, применяя те настройки, которые
          предалгает нам jQuery на своем сайте
        </li>
      </ul>
      <div class="code-realisation">
        <ul class="list accordion">
          <li class="item">
            <span class="b5__ac-title"> Текст-превью </span>
            <p class="text">
              Далеко-далеко за, словесными горами в стране гласных и согласных
              живут рыбные тексты.
            </p>
          </li>
          <li class="item">
            <span class="b5__ac-title"> Текст-превью </span>
            <p class="text">
              Далеко-далеко за, словесными горами в стране гласных и согласных
              живут рыбные тексты.
            </p>
          </li>
          <li class="item">
            <span class="b5__ac-title"> Текст-превью </span>
            <p class="text">
              Далеко-далеко за, словесными горами в стране гласных и согласных
              живут рыбные тексты.
            </p>
          </li>
        </ul>
        <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
        <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
        <script src="js/b5.js"></script>
      </div>
    </div>
    <!-- Block 5 end -->
    <!-- Block 6 start -->
    <div class="b6 block">
      <p class="title"><span class="title-number">6.</span> Бургер меню</p>
      <p class="text">
        <span class="text-offset">Бургер меню</span> - это UI элемент,
        представляющий из себя скрытую область навигации. Бургер меню
        используется для экономии пространства на планшетных и мобильных
        устройствах, оно раскрывается по нажатию на него, в формате
        подстроенном под планшеты и мобильные устройства.
      </p>
      <p class="text">
        Бургер меню создается в блоке header и начинается оно с разметки в
        HTML, лучше заранее разметить его там, где вы хотите его увидеть,
        слева или справа от панели навигации.
      </p>
      <ul class="list">
        <li class="item">
          <span class="text-offset">Как сделать бургер меню?</span>
        </li>
        <li class="item">
          - Создаем разметку - она представляет из себя
          <span class="text-bg">&lt;<span class="tag-property">div</span>&gt;</span>
          с классом <span class="text-bg string">burger</span> и тремя
          <span class="text-bg">&lt;<span class="tag-property">span</span>&gt;</span>
          внутри с классом <span class="text-bg string">burger-line</span>
        </li>
        <li class="item">
          - Стили пишем в <span class="highlight">media.css</span>, на
          разрешении в котором у нас будет появляться бургер меню, обычно это
          1024px. Задаем стили классу
          <span class="text-bg selector">.burger</span> и его элементам с
          классом <span class="text-bg selector">.burger-line</span>
        </li>
        <li class="item">
          - Задаем стили для блока навигации с классом
          <span class="text-bg selector">.b6__nav-list</span> и его элементам
          с классом <span class="text-bg selector">.b6__nav-item</span>
        </li>
        <li class="item">
          - Создаем класс
          <span class="text-bg selector">.b6__nav--active</span> для того
          чтобы сделать меню видимым и выдвинуть его из левой части экрана.
        </li>
        <li class="item">
          - Создаем класс
          <span class="text-bg selector">.b6__burger--active</span>, для
          которого задаются стили для анимирования линий нашего бургера, чтобы
          они, при открытом меню навигации, превращались в крестик. Этот
          класс, в дальнейшем, при помощи Js мы будем инлайново встраивать в
          HTML, поэтому для него можно просто написать вложенность как в
          примере ниже
        </li>
        <li class="item">
          - Создаем js файл. Его работа будет заключаться в том, чтобы по
          клику на бургер открывать нам меню, делая классы с префиксом
          --active активными, активировать анимацию линий бургера, превращая
          их в крестик и по повторному нажатию закрывать меню
        </li>
      </ul>
      <div class="code-realisation">
        <div class="b6__nav">
          <ul class="b6__nav-list">
            <li class="b6__nav-item">Text</li>
            <li class="b6__nav-item">Text</li>
            <li class="b6__nav-item">Text</li>
            <li class="b6__nav-item">Text</li>
          </ul>
          <div class="b6__burger">
            <span class="b6__burger-line"></span>
            <span class="b6__burger-line"></span>
            <span class="b6__burger-line"></span>
          </div>
        </div>
        <script src="js/b6.js"></script>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">div class=</span><span class="string">"b6__nav"</span>&gt;
  &lt;<span class="tag-property">ul class=</span><span class="string">"b6__nav-list"</span>&gt;
    &lt;<span class="tag-property">li class=</span><span class="string">"b6__nav-item"</span>&gt;
      Text
    &lt;/<span class="tag-property">li</span>&gt;
    &lt;<span class="tag-property">li class=</span><span class="string">"b6__nav-item"</span>&gt;
      Text
    &lt;/<span class="tag-property">li</span>&gt;
    &lt;<span class="tag-property">li class=</span><span class="string">"b6__nav-item"</span>&gt;
      Text
    &lt;/<span class="tag-property">li</span>&gt;
    &lt;<span class="tag-property">li class=</span><span class="string">"b6__nav-item"</span>&gt;
      Text
    &lt;/<span class="tag-property">li</span>&gt;
  &lt;/<span class="tag-property">ul</span>&gt;
  &lt;<span class="tag-property">div class=</span><span class="string">"b6__burger"</span>&gt;
    &lt;<span class="tag-property">span class=</span><span class="string">"b6__burger-line"</span>&gt;&lt;/<span class="tag-property">span</span>&gt;
    &lt;<span class="tag-property">span class=</span><span class="string">"b6__burger-line"</span>&gt;&lt;/<span class="tag-property">span</span>&gt;
    &lt;<span class="tag-property">span class=</span><span class="string">"b6__burger-line"</span>&gt;&lt;/<span class="tag-property">span</span>&gt;
  &lt;/<span class="tag-property">div</span>&gt;
&lt;/<span class="tag-property">div</span>&gt;
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

<span class="comment">/* Браузерная разметка */</span>
<span class="selector">.b6__nav</span> {
  <span class="tag-property">width</span>: 100%;
  <span class="tag-property">display</span>: flex;
  <span class="tag-property">justify-content</span>: flex-end;
}

<span class="selector">.b6__nav-list</span> {
  <span class="tag-property">display</span>: flex;
}

<span class="selector">.b6__nav-item</span> {
  <span class="tag-property">cursor</span>: pointer;
  <span class="tag-property">margin-right</span>: 30px;
}

<span class="comment">/* Мобильная разметка с @media (max-width: 1024px) */</span>

<span class="selector">.b6__nav-list</span> {
  <span class="tag-property">position</span>: absolute;
  <span class="tag-property">top</span>: 0;
  <span class="tag-property">left</span>: 0;
  <span class="tag-property">width</span>: 50%;
  <span class="tag-property">min-width</span>: 250px;
  <span class="tag-property">height</span>: 300px;
  <span class="tag-property">z-index</span>: 1000;
  <span class="tag-property">flex-direction</span>: column;
  <span class="tag-property">padding</span>: 50px;
  <span class="tag-property">box-shadow</span>: 0 0 5px var(--gray);
  <span class="tag-property">background-color</span>: var(--white);
  <span class="comment">/* Скролл для меню */</span>
  <span class="tag-property">overflow-y</span>: auto;
  <span class="comment">/* Скрываем меню */</span>
  <span class="tag-property">visibility</span>: hidden;
  <span class="comment">/* Смещаем меню в левую часть экрана, за его пределы */</span>
  <span class="tag-property">transform</span>: translateX(-120%);
  <span class="tag-property">transition</span>: visibility 0.3s ease-in-out, transform 0.3s ease-in-out;
}

<span class="selector">.b6__nav-item</span> {
  <span class="tag-property">margin-right</span>: 0;
  <span class="tag-property">margin-bottom</span>: 30px;
}

<span class="selector">.b6__nav--active</span> {
  <span class="tag-property">visibility</span>: visible;
  <span class="tag-property">transform</span>: none;
}

<span class="selector">.b6__burger--active</span>
<span class="selector">.b6__burger-line:nth-child(2)</span> {
  <span class="tag-property">display</span>: none;
}

<span class="selector">.b6__burger--active</span>
<span class="selector">.b6__burger-line:first-child</span> {
  <span class="tag-property">align-items</span>: center;
  <span class="tag-property">transform</span>: translate(0, 11px) rotate(45deg);
  <span class="tag-property">transition</span>: transform 0.3s ease-in-out;
}

<span class="selector">.b6__burger--active</span>
<span class="selector">.b6__burger-line:last-child</span> {
  <span class="tag-property">align-items</span>: center;
  <span class="tag-property">transform</span>: translate(0, -11px) rotate(-45deg);
  <span class="tag-property">transition</span>: transform 0.3s ease-in-out;
}

<span class="selector">.b6__burger</span> {
  <span class="tag-property">width</span>: 40px;
  <span class="tag-property">height</span>: 25px;
  <span class="tag-property">display</span>: flex;
  <span class="tag-property">flex-direction</span>: column;
  <span class="tag-property">justify-content</span>: space-between;
  <span class="tag-property">cursor</span>: pointer;
}

<span class="selector">.b6__burger-line</span> {
  <span class="tag-property">width</span>: 100%;
  <span class="tag-property">height</span>: 3px;
  <span class="tag-property">background-color</span>: var(--black);
}

<span class="comment">/* Чтобы сайт не скроллился пока мы не закроем меню */</span>
<span class="selector">.stop-scroll</span> {
  <span class="tag-property">overflow</span>: hidden;
}
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="property">let</span> <span class="value">b6__burger</span> = document.querySelector(<span class="string">".b6__burger"</span>);
<span class="property">let</span> <span class="value">b6__menu</span> = document.querySelector(<span class="string">".b6__nav-list"</span>);
<span class="property">let</span> <span class="value">b6__menuLinks</span> = <span class="value">b6__menu</span>.querySelectorAll(<span class="string">".b6__nav-item"</span>);

<span class="value">b6__burger</span>.<span class="selector">addEventListener</span>(<span class="string">"click"</span>, <span class="cycle-function">() =&gt;</span> {
  <span class="value">b6__burger</span>.classList.toggle(<span class="string">"b6__burger--active"</span>);
  <span class="value">b6__menu</span>.classList.toggle(<span class="string">"b6__nav--active"</span>);
  document.body.classList.toggle(<span class="string">"stop-scroll"</span>);
});

<span class="value">b6__menuLinks</span>.forEach(<span class="value">element</span> <span class="cycle-function">=&gt;</span> {
  <span class="value">element</span>.<span class="selector">addEventListener</span>(<span class="string">"click"</span>, <span class="cycle-function">() =&gt;</span> {
    <span class="value">b6__burger</span>.classList.remove(<span class="string">"b6__burger--active"</span>);
    <span class="value">b6__menu</span>.classList.remove(<span class="string">"b6__nav--active"</span>);
    document.body.classList.remove(<span class="string">"stop-scroll"</span>);
  });
});
</code>
</pre>
      </div>
    </div>
    <!-- Block 6 end -->
    <!-- Block 7 start -->
    <div class="b7 block">
      <p class="title">
        <span class="title-number">7.</span> Кастомный селект
      </p>
      <p class="text">
        <span class="text-offset">Селект</span> - это UI элемент,
        представляющий из себя раскрывающийся список с множеством элементов.
      </p>
      <p class="text">
        Селект можно сделать и нативным, но он не будет настолько гибким, как
        селект добавленный при помощи плагина
      </p>
      <div class="code-realisation">
        <p class="text">Нативный селект:</p>
        <select class="b7__native-select">
          <option>Пункт 1</option>
          <option>Пункт 2</option>
          <option>Пункт 3</option>
        </select>
      </div>
      <p class="text">
        Плагины позволяют сделать селект более гибким в настройке и
        кастомизации, в данном примере мы рассмотрим плагин под названием
        <a class="link" href="https://github.com/Choices-js/Choices" target="_blank">Choices</a>.
      </p>
      <p class="text">
        Инструкция по его подключению, как и почти всех плагинов находящихся
        на GitHub, находится в файле README, к любой хорошей библиотеке
        прикладывается понятная инструкция по подключению плагина. Как и все
        плагины, этот можно подключить тремя способами: скачать через npm,
        скачать архив с GitHub и установить его себе в проект, либо через CDN,
        те по прямой ссылке, воспользуется вторым способом и скачаем архив, из
        которого нам понадобится всего два файла
        <span class="highlight">choices.min.css</span>, подключаем его в head
        нашей страницы, и <span class="highlight">choices.min.js</span>,
        подключаем перед закрывающим тегом body.
      </p>
      <p class="text">
        После того как мы добавили два этих файла в HTML, необходимо базово
        разметить select, и дать ему название класса, далее инициализировать
        плагин, сделать это можно создав JS файл под добавленным ранее, и
        прописать в нем код для инициализации.
      </p>
      <p class="text">
        После инициализации, можем перейти на GitHub данного плагина и перейти
        к разделу Setup -&gt; passing oprions, тут находятся все нужные
        настройки для кастомизации вашего селекта.
      </p>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">select class=</span><span class="string">"b7__custom-select"</span>&gt;
  &lt;<span class="tag-property">option</span>&gt;
    Пункт 1
  &lt;/<span class="tag-property">option</span>&gt;
  &lt;<span class="tag-property">option</span>&gt;
    Пункт 2
  &lt;/<span class="tag-property">option</span>&gt;
  &lt;<span class="tag-property">option</span>&gt;
    Пункт 3
  &lt;/<span class="tag-property">option</span>&gt;
&lt;/<span class="tag-property">select</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"libs/js/choices.min.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
&lt;<span class="tag-property">script src=</span><span class="string">"js/b7.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>
<span class="comment">// Код для инициализации плагина</span>
<span class="property">const</span> <span class="value">element</span> = document.querySelector(<span class="string">".b7__custom-select"</span>);
<span class="property">const</span> <span class="value">choices</span> = new Choices(<span class="value">element</span>);
</code>
</pre>
      </div>
      <div class="code-realisation">
        <p class="text">Кастомный селект:</p>
        <select class="b7__custom-select">
          <option>Пункт 1</option>
          <option>Пункт 2</option>
          <option>Пункт 3</option>
        </select>
        <script src="libs/js/choices.min.js"></script>
        <script src="js/b7.js"></script>
      </div>
    </div>
    <!-- Block 7 end -->
    <!-- Block 8 start -->
    <div class="b8 block">
      <p class="title">
        <span class="title-number">8.</span> Добавление Яндекс карты.
      </p>
      <p class="text">
        Для того чтобы добавить карту на свой сайт, необходимо перейти на сайт
        <a class="link" href="https://yandex.ru/dev/maps/jsapi/doc/2.1/quick-start/index.html?from=jsapi"
          target="_blank">Яндекса</a>
        и ознакомиться с документацией, всего в 4 шага можно добавить яндекс
        карту к себе в проект!
      </p>
      <p class="text">
        Для нашего примера, можно начинать со второго шага, те с добавления
        API Яндекс карты, в виде JS файла. Далее мы создаем контейнер для
        карты (в примере все стили для него записаны инлайново, этого лучше
        избежать и задать div"у класс и стилизовать уже его), далее важный
        шаг, это добавления id вашему контейнеру для карты, его необходимо
        назвать как в примере, те
        <span class="text-bg"><span class="tag-property">id</span> =
          <span class="string">"map"</span></span>
      </p>
      <p class="text">
        Создаем JS файл, подключаем его под API Яндекс карт в HTML, и
        инициализируем карту.
      </p>
      <p class="text">
        Карту можно стилизовать, добавлять свои поинты, менять цвет карты,
        обозначения и тд. все что изменено в этой карте, вы можете увидеть в
        примерах кода ниже.
      </p>
      <div class="code-realisation">
        <div class="b8__map" id="map"></div>
        <script src="https://api-maps.yandex.ru/2.1/?apikey=ваш API-ключ&lang=ru_RU" type="text/javascript"></script>
        <script src="js/b8.js"></script>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">div class</span>=<span class="string">"b8__map"</span><span class="tag-property"> id</span>=<span class="string">"map"</span>&gt;&lt;/<span class="tag-property">div</span>&gt;
&lt;<span class="tag-property">script src</span>=<span class="string">"https://api-maps.yandex.ru/2.1/?apikey=ваш API-ключ&lang=ru_RU"</span><span class="tag-property"> type</span>=<span class="string">"text/javascript"</span>&lt;/<span class="tag-property">script</span>&gt;
&lt;<span class="tag-property">script src</span>=<span class="string">"js/b7.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

.<span class="selector">b8__map</span> {
  <span class="tag-property">width</span>: 600px;
  <span class="tag-property">height</span>: 400px;
}
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="value">ymaps</span>.ready(init);
<span class="cycle-function">function</span> init(){
  <span class="comment">// Создание карты.</span>
  <span class="property">var</span> <span class="value">myMap</span> = <span class="property">new</span> <span class="value">ymaps</span>.Map(<span class="string">"map"</span>, {
    <span class="comment">// Координаты центра карты.</span>
    <span class="comment">// Порядок по умолчанию: «широта, долгота», определить их можно по этой <a class="link" href="http://dimik.github.io/ymaps/examples/location-tool/" target="_blank">ссылке</a></span>
    <span class="value">center:</span> [55.76, 37.64],
    <span class="comment">// Уровень масштабирования. от 0 (весь мир) до 19.</span>
    <span class="value">zoom:</span> 10
  });
  <span class="comment">// Добавление новой, встроенной метки, геообъекта.</span>
  <span class="property">var</span> <span class="value">myGeoObject</span> = <span class="property">new</span> <span class="value">ymaps</span>.GeoObject({
    <span class="value">myGeoObject:</span> {
      <span class="value">type:</span> <span class="string">"Points"</span>
      <span class="value">coordinates:</span> [55.8, 37.8],
    }
  });
  <span class="comment">// Добавление кастомной метки в виде любой svg картинки.</span>
  <span class="property">var</span> <span class="value">myPlacemark</span> = <span class="property">new</span> <span class="value">ymaps</span>.Placemark([55.76, 37.56], {}, {
    <span class="value">iconLayout:</span> <span class="string">"default#image"</span>,
    <span class="value">iconImageHref:</span> <span class="string">"./assets/svg/eevee.svg"</span>,
    <span class="value">iconImageSize:</span> [30, 42],
    <span class="value">iconImageOffset:</span> [-3, -42]
  });
  <span class="comment">// Вызов функций и активация заданых настроек.</span>
  <span class="value">myMap</span>.<span class="value">geoObjects</span>.add(<span class="value">myPlacemark</span>);
  <span class="value">myMap</span>.<span class="value">geoObjects</span>.add(<span class="value">myGeoObject</span>);
}
</code>
</pre>
      </div>
    </div>
    <!-- Block 8 end -->
    <!-- Block 9 start -->
    <div class="b9 block">
      <p class="title">
        <span class="title-number">9.</span> Кастомный скролл.
      </p>
      <p class="text">
        Основная проблема того что мы создаем кастомный скроллбар заключается
        в том, что во всех браузерах они отображаются по разнному, а стремясь
        к кроссбраузерности, это является помехой, так же нативные скроллбары
        являются очень некрасивыми и часто выбиваются из общего дизайна сайта.
        Реализовывать кастомный скроллбар мы будем при помощи библиотеки
        <a class="link" href="https://github.com/Grsmto/simplebar/tree/master/packages/simplebar"
          target="_blank">SimpleBar</a>
      </p>
      <p class="text">
        Библиотека находится на GitHub, как и раньше, в README необходимо
        найти ключевое слово <span class="highlight">Get started</span> и
        следовать шагам по подключению библиотеки. Нам предлагают уже знакомые
        варианты подключения библиотеки, мы выбираем подключение через ссылки,
        те CDN, не забывая при этом подключить CSS в head сайта. Далее, важный
        момент, необходимо указать data атрибут как в примере -
        <span class="text-bg value">data-simplebar</span>
      </p>
      <p class="text">
        Кастомизируем скроллбар через CSS класс
        <span class="text-bg selector">.simplebar-scrollbar::before {...}</span>
      </p>
      <div class="code-realisation">
        <div class="b9__scroll-wrapper" data-simplebar>
          <p class="text">
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Unde
            reprehenderit quasi perferendis, ullam nemo minus dolor alias
            porro quidem? Nisi doloribus error cupiditate dolorum possimus
            provident tempore blanditiis enim nostrum. Lorem ipsum dolor sit
            amet consectetur adipisicing elit. Unde reprehenderit quasi
            perferendis, ullam nemo minus dolor alias porro quidem? Nisi
            doloribus error cupiditate dolorum possimus provident tempore
            blanditiis enim nostrum. Lorem ipsum dolor sit amet consectetur
            adipisicing elit. Unde reprehenderit quasi perferendis, ullam nemo
            minus dolor alias porro quidem? Nisi doloribus error cupiditate
            dolorum possimus provident tempore blanditiis enim nostrum. Lorem
            ipsum dolor sit amet consectetur adipisicing elit. Unde
            reprehenderit quasi perferendis, ullam nemo minus dolor alias
            porro quidem? Nisi doloribus error cupiditate dolorum possimus
            provident tempore blanditiis enim nostrum.
          </p>
        </div>
        <script src="https://unpkg.com/simplebar@latest/dist/simplebar.min.js"></script>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">div class</span>=<span class="string">"b9__scroll-wrapper"</span><span class="value"> data-simplebar</span>&gt;
  &lt;<span class="tag-property">p class</span>=<span class="string">"text"</span>&gt;
  Lorem ipsum dolor sit amet consectetur adipisicing elit. Delectus quaerat officia veritatis enim repellat, in natus similique deleniti, vero quam, laboriosam labore voluptates incidunt exercitationem. Quibusdam voluptatum ratione veritatis libero.
  &lt;/<span class="tag-property">p</span>&gt;
  &lt;<span class="tag-property">script src</span>=<span class="string">"https://unpkg.com/simplebar@latest/dist/simplebar.min.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
&lt;/<span class="tag-property">div</span>&gt;
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

.<span class="selector">b9__scroll-wrapper</span> {
  <span class="tag-property">width</span>: 400px;
  <span class="tag-property">height</span>: 400px;
}

.<span class="selector">simplebar-scrollbar::before</span> {
  <span class="tag-property">background-image</span>: linear-gradient(180deg, red, orange, yellow, lime, green, aqua, blue);
}
</code>
</pre>
      </div>
    </div>
    <!-- Block 9 end -->
    <!-- Block 10 start -->
    <div class="b10 block">
      <p class="title">
        <span class="title-number">10.</span> Валидация формы и ее
        кастомизация.
      </p>
      <p class="text">
        Для красивой формы и ее валидации, где для ввода номера телефона
        используется маска, а необходимые поля подсвечиваются, мы будем
        использовать две библиотеки:
        <a class="link" href="https://github.com/RobinHerbots/Inputmask" target="_blank">Inputmask</a>
        - отвечающий за маску поля для ввода номера телефона, и
        <a class="link" href="https://github.com/horprogs/Just-validate/tree/v1/dist/js"
          target="_blank">Just-validate</a>
        - отвечающий за валидацию полей формы
      </p>
      <p class="text">
        Начинаем с разметки HTML, прописываем поля для формы - имя, телефон,
        email, так же добаляем кнопку для отправки. Важный момент, помимо
        стандартных атрибутов формы, к ним добавляются еще и data атрибуты,
        которые будут отбрабатываться плагином валидации, их необходимо
        добавить.
      </p>
      <p class="text">
        Скачиваем архив с плагином <span class="highlight">Inputmask</span> с
        GitHub, находим и подключаем единственный нужный нам файл
        <span class="highlight">inputmask.min.js</span> и инициализируем его
        при помощи подключенного ниже JS файла.
      </p>
      <p class="text">
        После чего можно перейти к подключению
        <span class="highlight">Just-validate</span>. Его необходимо скачать и
        забрать к себе в проект один файл
        <span class="highlight">just-validate.min.js</span>, подключив его
        рядом с предыдущим плагином, инициализировать можно в том же файле что
        мы создали ранее. Главное это задать в инициализации тот класс,
        которым мы назвали нашу форму.
      </p>
      <div class="code-realisation">
        <form class="b10__form" action="https://jsonplaceholder.typicode.com/posts" method="post" target="_blank">
          <input class="b10__form-input" name="Имя" type="text" placeholder="Имя" data-validate-field="name" />
          <input class="b10__form-input" name="Телефон" type="tel" placeholder="Телефон" data-validate-field="tel"
            data-validate-rules="phone" />
          <input class="b10__form-input" name="email" type="email" placeholder="Email" data-validate-field="mail" />
          <button class="b10__form-button">Отправить</button>
        </form>
        <script src="libs/js/inputmask.min.js"></script>
        <script src="libs/js/just-validate.min.js"></script>
        <script src="js/b10.js"></script>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-html">HTML</span>

&lt;<span class="tag-property">form class</span>=<span class="string">"b10__form"</span> <span class="value">action</span>=<span class="string">"https://jsonplaceholder.typicode.com/posts"</span> <span class="value">method</span>=<span class="string">"post"</span> <span class="value">target</span>=<span class="string">"_blank"</span>&gt;
  &lt;<span class="tag-property">input class</span>=<span class="string">"b10__form-input"</span> <span class="value">name</span>=<span class="string">"Имя"</span> <span class="value">type</span>=<span class="string">"text"</span> <span class="value">placeholder</span>=<span class="string">"Имя"</span> <span class="value">data-validate-field</span>=<span class="string">"name"</span>&gt;
  &lt;<span class="tag-property">input class</span>=<span class="string">"b10__form-input"</span> <span class="value">name</span>=<span class="string">"Телефон"</span> <span class="value">type</span>=<span class="string">"tel"</span> <span class="value">placeholder</span>=<span class="string">"Телефон"</span> <span class="value">data-validate-field</span>=<span class="string">"tel"</span>&gt;
  &lt;<span class="tag-property">input class</span>=<span class="string">"b10__form-input"</span> <span class="value">name</span>=<span class="string">"email"</span> <span class="value">type</span>=<span class="string">"email"</span> <span class="value">placeholder</span>=<span class="string">"Email"</span> <span class="value">data-validate-field</span>=<span class="string">"mail"</span>&gt;
  &lt;<span class="tag-property">button class</span>=<span class="string">"b10__form-button"</span>&gt;
    Отправить
  &lt;/<span class="tag-property">button</span>&gt;
&lt;/<span class="tag-property">form</span>&gt;
&lt;<span class="tag-property">script src</span>=<span class="string">"libs/js/inputmask.min.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
&lt;<span class="tag-property">script src</span>=<span class="string">"libs/js/just-validate.min.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
&lt;<span class="tag-property">script src</span>=<span class="string">"js/b10.js"</span>&gt;&lt;/<span class="tag-property">script</span>&gt;
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-css">CSS</span>

.<span class="selector">b10__form</span> {
  <span class="tag-property">max-width</span>: 30%;
  <span class="tag-property">display</span>: flex;
  <span class="tag-property">flex-direction</span>: column;
}

.<span class="selector">b10__form-input</span> {
  <span class="tag-property">margin-bottom</span>: 20px;
}

.<span class="selector">b10__form-button</span> {
  <span class="tag-property">width</span>: fit-content;
  <span class="tag-property">display</span>: inline-flex;
  <span class="tag-property">justify-content</span>: flex-start;
  <span class="tag-property">padding</span>: 10px;
  <span class="tag-property">background-color</span>: var(--gray);
  <span class="tag-property">border-radius</span>: 10px;
}
</code>
</pre>
      </div>
      <div class="console">
        <pre>
<code class="code">
<span class="console-title title-js">JS</span>

<span class="comment">// Инициализация Inputmask</span>
<span class="comment">// Скрипт находит на странице все атрибуты с type="tel"</span>
<span class="property">var</span> <span class="value">selector</span> = document.querySelector(<span class="string">"input[type="tel"]"</span>);
<span class="comment">// Создаем пример того как должна выглядеть маска и номер в ней (9 можно заменить на любую цифру)</span>
<span class="property">var</span> <span class="value">im</span> = <span class="property">new</span> Inputmask(<span class="string">"+7 (999)-999-99-99"</span>);

<span class="value">im</span>.mask(<span class="value">selector</span>);

<span class="comment">// Инициализация JustValidate</span>
<span class="property">new</span> JustValidate(<span class="string">".b10__form"</span>, {
<span class="value">rules</span>: {
  <span class="comment">// Проверки для имени</span>
  <span class="value">name</span>: {
    <span class="value">required</span>: <span class="property">true</span>,
    <span class="value">minLength</span>: 2,
    <span class="value">maxLength</span>: 20
  },
  <span class="comment">// Проверки для телефона</span>
  <span class="value">tel</span>: {
    <span class="value">required</span>: <span class="property">true</span>,
    <span class="comment">// Собственная функция валидации которая проверяет только цифры, без учета строк и тире</span>
    <span class="cycle-function">function</span>: (name, value) <span class="cycle-function">=&gt;</span> {
      <span class="property">const</span> <span class="value">phone</span> = <span class="value">selector</span>.<span class="value">inputmask</span>.unmaskedvalue()
      <span class="cycle-function">return</span> <span class="value">Number</span>(<span class="value">phone</span>) && <span class="value">phone</span>.<span class="value">length</span> === 10
    }
  },
  <span class="comment">// Проверки для email</span>
  <span class="value">mail</span>: {
    <span class="value">required</span>: <span class="property">true</span>,
    <span class="value">email</span>: <span class="property">true</span>
  },
},
});
</code>
</pre>
      </div>
    </div>
    <!-- Block 10 end -->
  </div>
</body>

</html>